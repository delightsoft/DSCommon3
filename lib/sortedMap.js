"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var Result, checkItemName, finish, index, invalidArg, isResult, sortedMap;
  Result = require('./result');

  var _require = require('./utils');

  checkItemName = _require.checkItemName;
  var _require$err = _require.err;
  invalidArg = _require$err.invalidArg;
  isResult = _require$err.isResult;

  index = function index(result, resValue) {
    var i, item, j, len, ref;

    if (!isResult(result)) {
      invalidArg('result', result);
    }

    if (!(_typeof(resValue) === 'object' && resValue !== null && resValue.hasOwnProperty('$$list'))) {
      invalidArg('resValue', resValue);
    }

    ref = resValue.$$list; // index =

    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      item = ref[i];
      item.$$index = i;
    }
  };

  finish = function finish(result, resValue, opts) {
    var item, j, len, optsSkipProps, optsValidate, ref;

    if (!isResult(result)) {
      invalidArg('result', result);
    }

    if (!(_typeof(resValue) === 'object' && resValue !== null && resValue.hasOwnProperty('$$list'))) {
      invalidArg('resValue', resValue);
    }

    if (!(opts === void 0 || _typeof(opts) === 'object' && opts !== null && !Array.isArray(opts))) {
      invalidArg('opts', opts);
    }

    if (!(opts != null ? opts.hasOwnProperty('skipProps') : void 0)) {
      // list of prop that should not be reported in validation
      optsSkipProps = void 0;
    } else {
      if (!((optsSkipProps = opts.skipProps) === void 0 || optsSkipProps === null || Array.isArray(optsSkipProps))) {
        invalidArg('opts.skipProps', opts.skipProps);
      }
    }

    if (!(opts != null ? opts.hasOwnProperty('validate') : void 0)) {
      // false - exclude validation for extra props
      optsValidate = true;
    } else {
      if (typeof (optsValidate = opts.validate) !== 'boolean') {
        invalidArg('opts.validate', opts.validate);
      }
    }

    if (result.isError) {
      // just remove $$src in case of prev error
      optsValidate = false;
    }

    if (optsValidate) {
      item = void 0;
      result.context(function (path) {
        return Result.prop(item.name)(path);
      }, function () {
        var i, j, k, len, ref;
        ref = resValue.$$list;

        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          item = ref[i];

          if (optsValidate && item.hasOwnProperty('$$src')) {
            k = void 0;
            result.context(function (path) {
              return Result.prop(k)(path);
            }, function () {
              for (k in item.$$src) {
                if (!(item.hasOwnProperty(k) || k.startsWith('$') || (optsSkipProps != null ? optsSkipProps.indexOf(k) : void 0) >= 0)) {
                  result.error('dsc.unexpectedProp', {
                    value: item.$$src[k]
                  });
                }
              }
            });
          }

          delete item.$$src; // result.context
        }
      });
    } else {
      ref = resValue.$$list; // finish =

      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        delete item.$$src;
      }
    }
  };

  sortedMap = function sortedMap(result, value, opts) {
    var fixedName, i, item, items, j, k, l, len, len1, len2, list, m, newItem, optsAfter, optsBefore, optsBoolean, optsCheckName, optsGetValue, optsReservedNames, optsString, res, v;

    if (!isResult(result)) {
      invalidArg('result', result);
    }

    if (!(opts === void 0 || _typeof(opts) === 'object' && opts !== null && !Array.isArray(opts))) {
      invalidArg('opts', opts);
    }

    if (!(opts != null ? opts.hasOwnProperty('checkName') : void 0)) {
      // function that checks names of items. Default: 'checkItemName' is used
      optsCheckName = null;
    } else {
      if (typeof (optsCheckName = opts.checkName) !== 'function') {
        invalidArg('opts.checkName', opts.checkName);
      }
    }

    if (!(opts != null ? opts.hasOwnProperty('getValue') : void 0)) {
      // function that creates new item out of non-object value
      optsGetValue = null;
    } else {
      if (typeof (optsGetValue = opts.getValue) !== 'function') {
        invalidArg('opts.getValue', opts.getValue);
      }
    }

    if (!(opts != null ? opts.hasOwnProperty('string') : void 0)) {
      // true - val could be list of strings or a comma delimited string
      optsString = false;
    } else {
      if (typeof (optsString = opts.string) !== 'boolean') {
        invalidArg('opts.string', opts.string);
      }
    }

    if (!(opts != null ? opts.hasOwnProperty('boolean') : void 0)) {
      // true - map, can express presents of an item, by using true as a value
      optsBoolean = false;
    } else {
      if (typeof (optsBoolean = opts["boolean"]) !== 'boolean') {
        invalidArg('opts.boolean', opts["boolean"]);
      }
    }

    if (!(opts != null ? opts.hasOwnProperty('before') : void 0)) {
      optsBefore = [];
    } else {
      if (!Array.isArray(optsBefore = opts.before)) {
        invalidArg('opts.before', opts.before);
      }
    }

    if (!(opts != null ? opts.hasOwnProperty('after') : void 0)) {
      optsAfter = [];
    } else {
      if (!Array.isArray(optsAfter = opts.after)) {
        invalidArg('opts.after', opts.after);
      }
    }

    if (!(opts != null ? opts.hasOwnProperty('reservedNames') : void 0)) {
      optsReservedNames = void 0;
    } else {
      if (!Array.isArray(optsReservedNames = opts.reservedNames)) {
        invalidArg('opts.reservedNames', opts.reservedNames);
      }
    }

    res = {};
    list = [];

    for (j = 0, len = optsBefore.length; j < len; j++) {
      item = optsBefore[j];
      newItem = {
        name: item.name,
        $$src: item
      };
      res[item.name] = newItem;
      list.push(newItem);
    }

    if (optsString && typeof value === 'string' && value.length > 0) {
      // на вход дали строку
      items = function () {
        var l, len1, ref, results;
        ref = value.split(',');
        results = [];

        for (l = 0, len1 = ref.length; l < len1; l++) {
          v = ref[l];

          if (v.trim()) {
            results.push(v.trim());
          }
        }

        return results;
      }();

      if (items.length === 0) {
        result.error('dsc.invalidValue', {
          value: value
        });
      } else {
        for (i = l = 0, len1 = items.length; l < len1; i = ++l) {
          v = items[i];

          if (!(optsCheckName ? fixedName = optsCheckName(v) : checkItemName(v))) {
            result.error('dsc.invalidName', {
              value: v
            });
            continue;
          }

          if (typeof fixedName === 'string') {
            v = fixedName;
          }

          if (optsReservedNames && optsReservedNames.indexOf(v) !== -1) {
            result.error('dsc.reservedName', {
              value: v
            });
            continue;
          }

          if (res.hasOwnProperty(v)) {
            result.error(Result.index(i), 'dsc.duplicatedName', {
              value: v
            });
            continue;
          }

          list.push(res[v] = {
            name: v
          });
        }
      }
    } else if (_typeof(value) === 'object' && value !== null) {
      // на вход дали map или массив
      if (Array.isArray(value)) {
        i = void 0;
        result.context(function (path) {
          return Result.index(i)(path);
        }, function () {
          var clone, len2, m;

          for (i = m = 0, len2 = value.length; m < len2; i = ++m) {
            v = value[i];

            if (optsString && typeof v === 'string' && v.length > 0) {
              if (!(optsCheckName ? fixedName = optsCheckName(v) : checkItemName(v))) {
                result.error('dsc.invalidName', {
                  value: v
                });
                continue;
              }

              if (typeof fixedName === 'string') {
                v.name = fixedName;
              }

              if (optsReservedNames && optsReservedNames.indexOf(v.name) !== -1) {
                result.error('dsc.reservedName', {
                  value: v.name
                });
                continue;
              }

              res[v] = clone = {
                name: v
              };
            } else {
              if (!(_typeof(v) === 'object' && v !== null && !Array.isArray(v))) {
                result.error('dsc.invalidValue', {
                  value: v
                });
                continue;
              } else if (!v.hasOwnProperty('name')) {
                result.error('dsc.missingProp', {
                  value: 'name'
                });
                continue;
              }

              if (!(optsCheckName ? fixedName = optsCheckName(v.name) : checkItemName(v.name))) {
                result.error('dsc.invalidName', {
                  value: v.name
                });
                continue;
              }

              if (typeof fixedName === 'string') {
                v.name = fixedName;
              }

              if (optsReservedNames && optsReservedNames.indexOf(v.name) !== -1) {
                result.error('dsc.reservedName', {
                  value: v.name
                });
              }

              if (!!res.hasOwnProperty(v.name)) {
                result.error('dsc.duplicatedName', {
                  value: v.name
                });
                continue;
              }

              res[v.name] = clone = {
                name: v.name,
                $$src: v
              };
            }

            list.push(clone); // result.context
            // if Array.isArray value
          }
        });
      } else {
        if (value.hasOwnProperty('$$list')) {
          throw new Error('Value was already processed by sortedMap()');
        }

        k = void 0;
        result.context(function (path) {
          return Result.prop(k)(path);
        }, function () {
          var clone;

          for (k in value) {
            v = value[k];

            if (!(optsCheckName ? fixedName = optsCheckName(k) : checkItemName(k))) {
              result.error('dsc.invalidName', {
                value: k
              });
              continue;
            }

            if (typeof fixedName === 'string') {
              k = fixedName;
            }

            if (optsReservedNames && optsReservedNames.indexOf(k) !== -1) {
              result.error('dsc.reservedName', {
                value: k
              });
              continue;
            }

            res[k] = clone = {
              name: k
            };

            if (_typeof(v) === 'object' && v !== null && !Array.isArray(v)) {
              if (!(!v.hasOwnProperty('name') || k === v.name)) {
                result.error('dsc.keyAndNameHasDifferenValues', {
                  value1: k,
                  value2: v.name
                });
                continue;
              } else {
                clone.$$src = v;
              }
            } else if (optsGetValue && optsGetValue(result, v, clone)) {
              void 0;
            } else if (optsBoolean && typeof v === 'boolean' && v === true) {
              res[k] = clone = {
                name: k
              };
            } else {
              result.error('dsc.invalidValue', {
                value: v
              });
              continue;
            }

            list.push(clone); // result.context
            // if typeof value == 'object' && object != null
          }
        });
      }
    } else {
      result.error('dsc.invalidValue', {
        value: value
      });
    }

    if (!result.isError) {
      for (m = 0, len2 = optsAfter.length; m < len2; m++) {
        item = optsAfter[m];
        newItem = {
          name: item.name,
          $$src: item
        };
        res[item.name] = newItem;
        list.push(newItem);
      }

      res.$$list = list;
      return res; // sortedMap =
    }
  }; // ----------------------------


  module.exports = sortedMap;
  sortedMap.index = index;
  sortedMap.finish = finish;
  sortedMap.empty = {
    $$list: []
  };
}).call(void 0);