"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var Result, checkItemName, finish, invalidArg, invalidArgValue, isResult, sortedMap;
  Result = require('./result');

  var _require = require('./utils');

  checkItemName = _require.checkItemName;
  var _require$err = _require.err;
  invalidArg = _require$err.invalidArg;
  invalidArgValue = _require$err.invalidArgValue;
  isResult = _require$err.isResult;

  finish = function finish(result, resValue, opts) {
    var item, j, len, optsSkipProps, optsValidate, ref;

    if (!isResult(result)) {
      invalidArg('result', result);
    }

    if (!(_typeof(resValue) === 'object' && resValue !== null && resValue.hasOwnProperty('$$list'))) {
      invalidArg('resValue', resValue);
    }

    if (!(opts === void 0 || _typeof(opts) === 'object' && opts !== null && !Array.isArray(opts))) {
      invalidArg('opts', opts);
    }

    if (!(opts != null ? opts.hasOwnProperty('skipProps') : void 0)) {
      // list of prop that should not be reported in validation
      optsSkipProps = void 0;
    } else {
      if (!((optsSkipProps = opts.skipProps) === void 0 || optsSkipProps === null || Array.isArray(optsSkipProps))) {
        invalidArgValue('opts.skipProps', opts.skipProps);
      }
    }

    if (!(opts != null ? opts.hasOwnProperty('validate') : void 0)) {
      // false - exclude validation for extra props
      optsValidate = true;
    } else {
      if (typeof (optsValidate = opts.validate) !== 'boolean') {
        invalidArgValue('opts.validate', opts.validate);
      }
    }

    if (result.isError) {
      // just remove $$src in case of prev error
      optsValidate = false;
    }

    if (optsValidate) {
      item = void 0;
      result.context(function (path) {
        return Result.item(item.name)(path);
      }, function () {
        var j, k, len, ref;
        ref = resValue.$$list;

        for (j = 0, len = ref.length; j < len; j++) {
          item = ref[j];

          if (optsValidate && item.hasOwnProperty('$$src')) {
            for (k in item.$$src) {
              if (!(item.hasOwnProperty(k) || k.startsWith('$') || (optsSkipProps != null ? optsSkipProps.indexOf(k) : void 0) >= 0)) {
                result.error('dsc.unexpectedProp', {
                  value: k
                });
              }
            }
          }

          delete item.$$src; // result.context
        }
      });
    } else {
      ref = resValue.$$list; // finish =

      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        delete item.$$src;
      }
    }
  };

  sortedMap = function sortedMap(result, value, opts) {
    var fixedName, i, items, j, k, len, list, optsBoolean, optsCheckName, optsGetValue, optsIndex, optsString, res, v;

    if (!isResult(result)) {
      invalidArg('result', result);
    }

    if (!(opts === void 0 || _typeof(opts) === 'object' && opts !== null && !Array.isArray(opts))) {
      invalidArg('opts', opts);
    }

    if (!(opts != null ? opts.hasOwnProperty('checkName') : void 0)) {
      // function that checks names of items. Default: 'checkItemName' is used
      optsCheckName = null;
    } else {
      if (typeof (optsCheckName = opts.checkName) !== 'function') {
        invalidArgValue('opts.checkName', opts.checkName);
      }
    }

    if (!(opts != null ? opts.hasOwnProperty('getValue') : void 0)) {
      // function that creates new item out of non-object value
      optsGetValue = null;
    } else {
      if (typeof (optsGetValue = opts.getValue) !== 'function') {
        invalidArgValue('opts.getValue', opts.getValue);
      }
    }

    if (!(opts != null ? opts.hasOwnProperty('string') : void 0)) {
      // true - val could be list of strings or a comma delimited string
      optsString = false;
    } else {
      if (typeof (optsString = opts.string) !== 'boolean') {
        invalidArgValue('opts.string', opts.string);
      }
    }

    if (!(opts != null ? opts.hasOwnProperty('boolean') : void 0)) {
      // true - map, can express presents of an item, by using true as a value
      optsBoolean = false;
    } else {
      if (typeof (optsBoolean = opts["boolean"]) !== 'boolean') {
        invalidArgValue('opts.boolean', opts["boolean"]);
      }
    }

    if (!(opts != null ? opts.hasOwnProperty('index') : void 0)) {
      // true - add to every result item $$index, with the index of item within result $$list
      optsIndex = false;
    } else {
      if (typeof (optsIndex = opts.index) !== 'boolean') {
        invalidArgValue('opts.index', opts.index);
      }
    }

    res = {};
    list = [];

    if (optsString && typeof value === 'string' && value.length > 0) {
      // на вход дали строку
      items = function () {
        var j, len, ref, results;
        ref = value.split(',');
        results = [];

        for (j = 0, len = ref.length; j < len; j++) {
          v = ref[j];

          if (v.trim()) {
            results.push(v.trim());
          }
        }

        return results;
      }();

      if (items.length === 0) {
        result.error('dsc.invalidValue', {
          value: value
        });
      } else {
        for (i = j = 0, len = items.length; j < len; i = ++j) {
          v = items[i];

          if (optsCheckName) {
            fixedName = optsCheckName(v.name);
          } else {
            checkItemName(v.name);
          }

          if (typeof fixedName === 'string') {
            v = fixedName;
          }

          if (res.hasOwnProperty(v)) {
            result.error(Result.index(i), 'dsc.duplicatedName', {
              value: v
            });
            continue;
          }

          if (optsIndex) {
            clone.$$index = list.length;
          }

          list.push(res[v] = {
            name: v
          });
        }
      }
    } else if (_typeof(value) === 'object' && value !== null) {
      // на вход дали map или массив
      if (Array.isArray(value)) {
        i = void 0;
        result.context(function (path) {
          return Result.index(i)(path);
        }, function () {
          var clone, l, len1;

          for (i = l = 0, len1 = value.length; l < len1; i = ++l) {
            v = value[i];

            if (optsString && typeof v === 'string' && v.length > 0) {
              if (!(optsCheckName ? fixedName = optsCheckName(v) : checkItemName(v))) {
                result.error('dsc.invalidName', {
                  value: v.name
                });
                continue;
              }

              if (typeof fixedName === 'string') {
                v.name = fixedName;
              }

              res[v] = clone = {
                name: v
              };
            } else {
              if (!(_typeof(v) === 'object' && v !== null && !Array.isArray(v))) {
                result.error('dsc.invalidValue', {
                  value: v
                });
                continue;
              } else if (!v.hasOwnProperty('name')) {
                result.error('dsc.missingProp', {
                  value: 'name'
                });
                continue;
              }

              if (!(optsCheckName ? fixedName = optsCheckName(v.name) : checkItemName(v.name))) {
                result.error('dsc.invalidName', {
                  value: v.name
                });
                continue;
              }

              if (typeof fixedName === 'string') {
                v.name = fixedName;
              }

              if (!!res.hasOwnProperty(v.name)) {
                result.error('dsc.duplicatedName', {
                  value: v.name
                });
                continue;
              }

              res[v.name] = clone = {
                name: v.name,
                $$src: v
              };
            }

            if (optsIndex) {
              clone.$$index = list.length;
            }

            list.push(clone); // result.context
            // if Array.isArray value
          }
        });
      } else {
        if (value.hasOwnProperty('$$list')) {
          throw new Error('Value was already processed by sortedMap()');
        }

        k = void 0;
        result.context(function (path) {
          return Result.prop(k)(path);
        }, function () {
          var clone;

          for (k in value) {
            v = value[k];

            if (!(optsCheckName ? fixedName = optsCheckName(k) : checkItemName(k))) {
              result.error('dsc.invalidName', {
                value: k
              });
            }

            if (typeof fixedName === 'string') {
              k = fixedName;
            }

            res[k] = clone = {
              name: k
            };

            if (_typeof(v) === 'object' && v !== null && !Array.isArray(v)) {
              if (!(!v.hasOwnProperty('name') || k === v.name)) {
                result.error('dsc.keyAndNameHasDifferenValues', {
                  value1: k,
                  value2: v.name
                });
                continue;
              } else {
                clone.$$src = v;
              }
            } else if (optsGetValue && optsGetValue(result, v, clone)) {
              void 0;
            } else if (optsBoolean && typeof v === 'boolean' && v === true) {
              res[k] = clone = {
                name: k
              };
            } else {
              result.error('dsc.invalidValue', {
                value: v
              });
              continue;
            }

            if (optsIndex) {
              clone.$$index = list.length;
            }

            list.push(clone); // result.context
            // if typeof value == 'object' && object != null
          }
        });
      }
    } else {
      result.error('dsc.invalidValue', {
        value: value
      });
    }

    if (!result.isError) {
      res.$$list = list;
      return res; // sortedMap =
    }
  }; // ----------------------------


  module.exports = sortedMap;
  sortedMap.finish = finish;
  sortedMap.empty = {
    $$list: []
  };
}).call(void 0);