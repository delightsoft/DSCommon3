"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var Result, processFields, processUdtypeFields, sortedMap;
  Result = require('../result');
  sortedMap = require('../sortedMap');
  processFields = require('./_processFields');

  processUdtypeFields = function processUdtypeFields(result, config) {
    var _buildOrder2, i, len, order, ref, stack, udType;

    if (result.isError) {
      return;
    }

    stack = [];
    order = [];

    _buildOrder2 = function _buildOrder(udType) {
      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var fields;

      if (!(_typeof(fields = udType.fields) === 'object' && fields !== null)) {
        return;
      }

      if (~stack.indexOf(udType.name)) {
        result.error('dsc.cycledUdtypes', {
          value: Object.assign([], stack)
        });
        return;
      }

      stack.push(udType.name);
      result.context(Result.prop(level === 0 ? 'udtypes' : 'fields'), function () {
        var itemName;
        itemName = void 0;
        result.context(function (path) {
          return Result.prop(itemName)(path);
        }, function () {
          var _processFields2;

          _processFields2 = function _processFields(fields) {
            var i, item, len, udt;

            if (!(_typeof(fields) === 'object' && fields !== null)) {
              return;
            }

            if (Array.isArray(fields)) {
              for (i = 0, len = fields.length; i < len; i++) {
                item = fields[i];

                if (typeof (itemName = item.name) === 'string') {
                  if (typeof item.type === 'string' && (udt = config.udtypes[item.type])) {
                    _buildOrder2(udt, level + 1);
                  } else if (item.fields) {
                    _processFields2(item.fields);
                  }
                }
              }
            } else {
              for (itemName in fields) {
                item = fields[itemName];

                if (typeof item.type === 'string' && (udt = config.udtypes[item.type])) {
                  _buildOrder2(udt, level + 1);
                } else if (item.fields) {
                  _processFields2(item.fields);
                }
              }
            }
          };

          return _processFields2(fields);
        });
      });

      if (!~order.indexOf(udType)) {
        // чтоб не пропустить зацикленность обрабаываем повторно udType даже когда он уже в order
        order.push(udType); // udType с fields используемые в этом типе должны идти раньше
      }

      return stack.pop();
    };

    ref = config.udtypes.$$list;

    for (i = 0, len = ref.length; i < len; i++) {
      udType = ref[i];

      if (udType.fields) {
        if (!~order.indexOf(udType)) {
          _buildOrder2(udType);
        }
      }
    }

    if (!result.isError) {
      udType = void 0;
      result.context(Result.prop('udtypes'), function () {
        return result.context(function (path) {
          return Result.prop(udType.name)(path);
        }, function () {
          var _clearIndex2, j, len1, results;

          results = [];

          for (j = 0, len1 = order.length; j < len1; j++) {
            udType = order[j];
            result.isError = false;
            udType.fields = processFields(result, {
              $$src: udType
            }, config, 'fields', true);

            if (!result.isError) {
              delete udType.fields.$$flat; // это не самостоятельная структура.  она будет вставляться в иерархию полей

              delete udType.fields.$$tags;

              _clearIndex2 = function _clearIndex(list) {
                var item, k, len2, results1;
                results1 = [];

                for (k = 0, len2 = list.length; k < len2; k++) {
                  item = list[k];
                  delete item.$$index;
                  delete item.$$mask;

                  if (item.fields) {
                    results1.push(_clearIndex2(item.fields.$$list));
                  } else {
                    results1.push(void 0);
                  }
                }

                return results1;
              };

              results.push(_clearIndex2(udType.fields.$$list));
            } else {
              results.push(void 0);
            }
          }

          return results;
        });
      });
    }

    if (!result.isError) {
      sortedMap.finish(result, config.udtypes);
    }
  }; // ----------------------------


  module.exports = processUdtypeFields;
}).call(void 0);