"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var BitArray, Result, calc, hasOwnProperty, isResult, link;
  Result = require('../result');
  BitArray = require('../bitArray');
  calc = require('../tags/_calc');
  hasOwnProperty = Object.prototype.hasOwnProperty;

  var _require = require('../utils/_err');

  isResult = _require.isResult;

  link = function link(config, noHelpers) {
    var EMPTY_FLAT_MAP, EMPTY_LIST, EMPTY_MAP, EMPTY_MAP_WITH_TAGS, EMPTY_MASK, EMPTY_TAGS, api, doc, freeze, j, l, len, len1, len2, len3, len4, linkFields, linkFlatMap, linkSortedMap, linkTags, linkUDTypes, m, method, n, o, ref, ref1, ref2, ref3, ref4, state, transition;

    freeze = function freeze(obj) {
      if (noHelpers) {
        return obj;
      }

      if (obj.hasOwnProperty('_mask')) {
        obj.list; // force mask to compute list
      }

      return Object.freeze(obj);
    };

    EMPTY_LIST = freeze([]);
    EMPTY_MAP_WITH_TAGS = freeze({
      $$list: EMPTY_LIST,
      $$tags: EMPTY_TAGS
    });
    EMPTY_MAP = freeze({
      $$list: EMPTY_LIST
    });
    EMPTY_MASK = freeze(new BitArray(EMPTY_MAP));
    EMPTY_TAGS = freeze({
      all: EMPTY_MASK
    });
    EMPTY_FLAT_MAP = freeze({
      $$list: EMPTY_LIST,
      $$flat: freeze({
        $$list: EMPTY_LIST
      }, {
        $$tags: EMPTY_TAGS
      })
    });
    EMPTY_MAP_WITH_TAGS = Object.freeze({
      $$list: [],
      $$tags: EMPTY_TAGS
    });

    linkSortedMap = function linkSortedMap(collection, noIndex, noFreeze) {
      var i, j, len, ref, res, v;

      if (collection === void 0) {
        if (noIndex) {
          return EMPTY_MAP;
        } else {
          return EMPTY_MAP_WITH_TAGS;
        }
      }

      res = {};
      ref = collection.list;

      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        v = ref[i];
        res[v.name] = v;

        if (!noIndex) {
          v.$$index = i;
        }
      }

      res.$$list = collection.list;

      if (collection.tags) {
        linkTags(res, collection);
      }

      if (noFreeze) {
        return res;
      } else {
        return freeze(res); // linkSortedMap =
      }
    };

    linkFlatMap = function linkFlatMap(collection, prop, noIndex, noMask) {
      var _linkLevel2, _buildMask, list, map, masks, res;

      if (collection === void 0) {
        return EMPTY_FLAT_MAP;
      }

      map = {};
      list = [];

      _linkLevel2 = function _linkLevel(level) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var j, len, v;

        for (j = 0, len = level.length; j < len; j++) {
          v = level[j];

          if (!noIndex) {
            v.$$index = list.length;
          }

          list.push(v);

          if (v.hasOwnProperty(prop)) {
            v[prop] = _linkLevel2(v[prop], "".concat(prefix).concat(v.name, "."));
          }

          map["".concat(prefix).concat(v.name)] = v;
        }

        return linkSortedMap({
          list: level
        }, true, prefix === ''); // _linkLevel
      };

      res = _linkLevel2(collection.list);
      (res.$$flat = map).$$list = freeze(list);
      freeze(map);

      if (collection.tags) {
        linkTags(res, collection);
      }

      if (!noMask) {
        masks = [];

        _buildMask = function buildMask(list) {
          var item, j, l, len, len1, mask, v;

          for (j = 0, len = list.length; j < len; j++) {
            item = list[j];

            for (l = 0, len1 = masks.length; l < len1; l++) {
              v = masks[l];
              v.set(item.$$index);
            }

            if (item.hasOwnProperty(prop)) {
              masks.push(item.$$mask = mask = new BitArray(res));

              _buildMask(item[prop].$$list);

              masks.pop(); // buildMask =
            }
          }
        };

        _buildMask(res.$$list);
      }

      return freeze(res); // linkFlatMode =
    };

    linkTags = function linkTags(res, collection) {
      var cache, k, noCache, ref, ref1, tags, v;
      tags = {
        all: freeze(new BitArray(res).invert())
      };
      ref = collection.tags;

      for (k in ref) {
        v = ref[k];
        tags[k] = freeze(new BitArray(((ref1 = res.$$flat) != null ? ref1.$$list : void 0) || res.$$list, v));
      }

      tags = res.$$tags = freeze(tags);

      if (!noHelpers) {
        cache = Object.create(null);

        noCache = function noCache(result, expr) {
          var localResult, r;

          if (!(_typeof(result) === 'object' && result !== null && result.hasOwnProperty('isError'))) {
            localResult = true;
            result = new Result();
            expr = result;
          }

          r = calc(result, res, expr);

          if (localResult) {
            result.throwIfError();
          }

          return r; // noCache =
        };

        res.$$calc = function (result, expr) {
          if (!(_typeof(result) === 'object' && result !== null && result.hasOwnProperty('isError'))) {
            expr = result;
            result = void 0;
          }

          if (hasOwnProperty.call(cache, expr)) {
            return cache[expr];
          }

          if (!result) {
            result = new Result();
          }

          return cache[expr] = noCache(result, expr); // res.$$calc =
        };

        res.$$calc.noCache = noCache; // linkTags =
      }
    };

    linkUDTypes = function linkUDTypes(config, list) {
      var j, len, refName, type;

      for (j = 0, len = list.length; j < len; j++) {
        type = list[j];

        if (type.hasOwnProperty('refers')) {
          type.refers = function () {
            var l, len1, ref, results;
            ref = type.refers;
            results = [];

            for (l = 0, len1 = ref.length; l < len1; l++) {
              refName = ref[l];
              results.push(config.docs[refName]);
            }

            return results;
          }();
        }

        if (type.hasOwnProperty('enum')) {
          // linkUDTypes =
          type["enum"] = linkSortedMap(type["enum"], true, false);
        }
      }
    };

    linkFields = function linkFields(config, list) {
      var field, j, len, refName, udt, udtList;

      for (j = 0, len = list.length; j < len; j++) {
        field = list[j];

        if (field.hasOwnProperty('udType')) {
          udt = config.udtypes[field.udType];
          udtList = [udt.name];

          while (udt.hasOwnProperty('udType')) {
            udt = config.udtypes[udt.udType];
            udtList.push(udt.name);
          }

          field.udType = freeze(udtList);
        }

        if (field.hasOwnProperty('refers')) {
          field.refers = function () {
            var l, len1, ref, results;
            ref = field.refers;
            results = [];

            for (l = 0, len1 = ref.length; l < len1; l++) {
              refName = ref[l];
              results.push(config.docs[refName]);
            }

            return results;
          }();
        }

        if (field.hasOwnProperty('enum')) {
          field["enum"] = linkSortedMap(field["enum"], true);
        }

        freeze(field); // linkFields =
      }
    };

    config.udtypes = linkSortedMap(config.udtypes, true, false);
    linkUDTypes(config, config.udtypes.$$list);
    config.docs = linkSortedMap(config.docs, true, false);
    ref = config.docs.$$list;

    for (j = 0, len = ref.length; j < len; j++) {
      doc = ref[j];
      doc.fields = linkFlatMap(doc.fields, 'fields', false, false);
      linkFields(config, doc.fields.$$flat.$$list);
      doc.actions = linkSortedMap(doc.actions, false, false);
      doc.states = linkSortedMap(doc.states, true, false);
      ref1 = doc.states.$$list;

      for (l = 0, len1 = ref1.length; l < len1; l++) {
        state = ref1[l];
        state.view = freeze(new BitArray(doc.fields.$$flat.$$list, state.view));
        state.update = freeze(new BitArray(doc.fields.$$flat.$$list, state.update));
        state.transitions = linkSortedMap(state.transitions, true, false);
        ref2 = state.transitions.$$list;

        for (m = 0, len2 = ref2.length; m < len2; m++) {
          transition = ref2[m];
          transition.next = doc.states[transition.next];
          freeze(transition);
        }

        freeze(state);
      }
    }

    config.api = linkSortedMap(config.api, true, false);
    ref3 = config.api.$$list;

    for (n = 0, len3 = ref3.length; n < len3; n++) {
      api = ref3[n];
      api.methods = linkSortedMap(api.methods, false, false);
      ref4 = api.methods.$$list;

      for (o = 0, len4 = ref4.length; o < len4; o++) {
        method = ref4[o];
        method.arguments = linkFlatMap(method.arguments, 'fields', false, false);
        linkFields(config, method.arguments.$$flat.$$list);
        method.result = linkFlatMap(method.result, 'fields', false, false);
        linkFields(config, method.result.$$flat.$$list);
        freeze(method);
      }

      freeze(api);
    }

    return config; // link =
  }; // ----------------------------


  module.exports = link;
}).call(void 0);