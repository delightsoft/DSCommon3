"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var $$newBuilder, BitArray, Result, calc, hasOwnProperty, isResult, link;
  Result = require('../result');
  BitArray = require('../bitArray');
  calc = require('../tags/_calc');
  hasOwnProperty = Object.prototype.hasOwnProperty;

  var _require = require('../utils/_err');

  isResult = _require.isResult;
  $$newBuilder = require('./helpers/new');

  link = function link(config, noHelpers) {
    var EMPTY_FLAT_MAP, EMPTY_LIST, EMPTY_MAP, EMPTY_MAP_WITH_TAGS, EMPTY_MASK, EMPTY_TAGS, api, apiKey, _deepFreeze, doc, docKey, freeze, j, l, len, len1, len2, len3, len4, linkFields, linkFieldsWithHelpers, linkFlatMap, linkSortedMap, linkTags, m, method, n, o, ref, ref1, ref2, ref3, ref4, state, transition;

    freeze = function freeze(obj) {
      if (noHelpers) {
        return obj;
      }

      if (obj.hasOwnProperty('_mask')) {
        obj.list; // force mask to compute list
      }

      return Object.freeze(obj);
    };

    _deepFreeze = function deepFreeze(obj) {
      var fld, fldName, results;
      freeze(obj);
      results = [];

      for (fldName in obj) {
        fld = obj[fldName];

        if (_typeof(fld) === 'object' && fld !== null) {
          results.push(_deepFreeze(fld));
        }
      }

      return results;
    };

    EMPTY_LIST = freeze([]);
    EMPTY_MAP_WITH_TAGS = freeze({
      $$list: EMPTY_LIST,
      $$tags: EMPTY_TAGS
    });
    EMPTY_MAP = freeze({
      $$list: EMPTY_LIST
    });
    EMPTY_MASK = freeze(new BitArray(EMPTY_MAP));
    EMPTY_TAGS = freeze({
      all: EMPTY_MASK
    });
    EMPTY_FLAT_MAP = freeze({
      $$list: EMPTY_LIST,
      $$flat: freeze({
        $$list: EMPTY_LIST
      }, {
        $$tags: EMPTY_TAGS
      })
    });
    EMPTY_MAP_WITH_TAGS = Object.freeze({
      $$list: [],
      $$tags: EMPTY_TAGS
    });

    linkSortedMap = function linkSortedMap(collection, noIndex, noFreeze) {
      var i, j, len, ref, res, v;

      if (collection === void 0) {
        if (noIndex) {
          return EMPTY_MAP;
        } else {
          return EMPTY_MAP_WITH_TAGS;
        }
      }

      res = {};
      ref = collection.list;

      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        v = ref[i];

        if (!noIndex) {
          v.$$index = i;
        }

        res[v.name] = noFreeze ? v : freeze(v);

        if (v.hasOwnProperty('extra')) {
          _deepFreeze(v.extra);
        }
      }

      res.$$list = collection.list;

      if (collection.tags) {
        linkTags(res, collection);
      }

      if (noFreeze) {
        return res;
      } else {
        return freeze(res); // linkSortedMap =
      }
    };

    linkFlatMap = function linkFlatMap(collection, prop, noIndex, noMask, noFreeze) {
      var _linkLevel2, _buildMask, list, map, masks, res;

      if (collection === void 0) {
        return EMPTY_FLAT_MAP;
      }

      map = {};
      list = [];

      _linkLevel2 = function _linkLevel(level) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var j, len, v;

        for (j = 0, len = level.length; j < len; j++) {
          v = level[j];

          if (!noIndex) {
            v.$$index = list.length;
          }

          list.push(v);

          if (v.hasOwnProperty(prop)) {
            v[prop] = _linkLevel2(v[prop], "".concat(prefix).concat(v.name, "."));
          }

          map["".concat(prefix).concat(v.name)] = v;
        }

        return linkSortedMap({
          list: level
        }, true, prefix === '' || noFreeze); // _linkLevel
      };

      res = _linkLevel2(collection.list);
      (res.$$flat = map).$$list = freeze(list);
      freeze(map);

      if (collection.tags) {
        linkTags(res, collection);
      }

      if (!noMask) {
        masks = [];

        _buildMask = function buildMask(list) {
          var item, j, l, len, len1, mask, v;

          for (j = 0, len = list.length; j < len; j++) {
            item = list[j];

            for (l = 0, len1 = masks.length; l < len1; l++) {
              v = masks[l];
              v.set(item.$$index);
            }

            if (item.hasOwnProperty(prop)) {
              masks.push(item.$$mask = mask = new BitArray(res));

              _buildMask(item[prop].$$list);

              masks.pop(); // buildMask =
            }
          }
        };

        _buildMask(res.$$list);
      }

      if (noFreeze) {
        return res;
      } else {
        return freeze(res); // linkFlatMode =
      }
    };

    linkTags = function linkTags(res, collection) {
      var cache, k, noCache, ref, ref1, tags, v;
      tags = {
        all: freeze(new BitArray(res).invert())
      };
      ref = collection.tags;

      for (k in ref) {
        v = ref[k];
        tags[k] = freeze(new BitArray(((ref1 = res.$$flat) != null ? ref1.$$list : void 0) || res.$$list, v));
      }

      tags = res.$$tags = freeze(tags);

      if (!noHelpers) {
        cache = Object.create(null);

        noCache = function noCache(result, expr) {
          var localResult, r;

          if (!(_typeof(result) === 'object' && result !== null && result.hasOwnProperty('isError'))) {
            localResult = true;
            result = new Result();
            expr = result;
          }

          r = calc(result, res, expr);

          if (localResult) {
            result.throwIfError();
          }

          return r; // noCache =
        };

        res.$$calc = function (result, expr) {
          if (!(_typeof(result) === 'object' && result !== null && result.hasOwnProperty('isError'))) {
            expr = result;
            result = void 0;
          }

          if (hasOwnProperty.call(cache, expr)) {
            return cache[expr];
          }

          if (!result) {
            result = new Result();
          }

          return cache[expr] = noCache(result, expr); // res.$$calc =
        };

        res.$$calc.noCache = noCache; // linkTags =
      }
    };

    linkFieldsWithHelpers = function linkFieldsWithHelpers(obj, prop, prefix) {
      var _assignKey, field, j, l, len, len1, ref, ref1;

      obj[prop] = linkFlatMap(obj[prop], 'fields', false, false, true);
      linkFields(config, obj[prop].$$flat.$$list);

      if (!noHelpers) {
        _assignKey = function assignKey(fields, levelPrefix) {
          var field, j, len, nextLevelPrefix, ref, results;
          ref = fields.$$list;
          results = [];

          for (j = 0, len = ref.length; j < len; j++) {
            field = ref[j];
            field.$$key = nextLevelPrefix = "".concat(levelPrefix, ".field.").concat(field.name);

            if (field.hasOwnProperty('udType')) {
              nextLevelPrefix = "type.".concat(field.udType[field.udType.length - 1]);
            }

            if (field.hasOwnProperty('fields')) {
              _assignKey(field.fields, nextLevelPrefix);
            }

            if (field.hasOwnProperty('enum')) {
              results.push(field["enum"].$$list.forEach(function (e) {
                e.$$key = "".concat(nextLevelPrefix, ".enum.").concat(e.name);
              }));
            } else {
              results.push(void 0);
            }
          }

          return results;
        };

        _assignKey(obj[prop], prefix);

        ref = obj[prop].$$flat.$$list;

        for (j = 0, len = ref.length; j < len; j++) {
          field = ref[j];

          if (field.hasOwnProperty('fields')) {
            field.fields.$$new = $$newBuilder(field.fields);
          }
        }

        obj[prop].$$new = $$newBuilder(obj[prop]);
      }

      ref1 = obj[prop].$$flat.$$list;

      for (l = 0, len1 = ref1.length; l < len1; l++) {
        field = ref1[l];

        if (field.hasOwnProperty('enum')) {
          field["enum"].$$list.forEach(function (i) {
            freeze(i);
          });
        }

        if (field.hasOwnProperty('fields')) {
          freeze(field.fields);
        }

        freeze(field); // linkFieldsWithHelpers =
      }
    };

    linkFields = function linkFields(config, list) {
      var field, i, j, len, refName;

      for (j = 0, len = list.length; j < len; j++) {
        field = list[j];

        if (field.hasOwnProperty('udType')) {
          freeze(field.udType);
        }

        if (field.hasOwnProperty('refers')) {
          field.refers = function () {
            var l, len1, ref, results;
            ref = field.refers;
            results = [];

            for (l = 0, len1 = ref.length; l < len1; l++) {
              refName = ref[l];
              results.push(config.docs[refName]);
            }

            return results;
          }();
        }

        if (field.hasOwnProperty('enum')) {
          field["enum"] = linkSortedMap(field["enum"], true, true);
          freeze(field["enum"]);
          freeze(field["enum"].$$list);
        }

        if (field.hasOwnProperty('regexp')) {
          i = regexp.lastIndexOf('/');
          field.regexp = new RegExp(field.regexp.substr(0, i - 1), field.regexp.substr(i + 1)); // linkFields =
        }
      }
    };

    config.docs = linkSortedMap(config.docs, true, true);
    freeze(config.docs);
    freeze(config.docs.$$list);
    ref = config.docs.$$list;

    for (j = 0, len = ref.length; j < len; j++) {
      doc = ref[j];

      if (!noHelpers) {
        doc.$$key = docKey = doc.name;
      }

      linkFieldsWithHelpers(doc, 'fields', docKey);
      doc.actions = linkSortedMap(doc.actions, false, false);
      doc.states = linkSortedMap(doc.states, true, false);

      if (!noHelpers) {
        doc.actions.$$list.forEach(function (a) {
          a.$$key = "".concat(docKey, ".action.").concat(a.name);
        });
        doc.states.$$list.forEach(function (s) {
          s.$$key = "".concat(docKey, ".state.").concat(s.name);
        });
      }

      ref1 = doc.states.$$list;

      for (l = 0, len1 = ref1.length; l < len1; l++) {
        state = ref1[l];
        state.view = freeze(new BitArray(doc.fields.$$flat.$$list, state.view));
        state.update = freeze(new BitArray(doc.fields.$$flat.$$list, state.update));
        state.transitions = linkSortedMap(state.transitions, true, false);
        ref2 = state.transitions.$$list;

        for (m = 0, len2 = ref2.length; m < len2; m++) {
          transition = ref2[m];
          transition.next = doc.states[transition.next];
          freeze(transition);
        }

        freeze(state);
      }

      freeze(doc);
    }

    config.api = linkSortedMap(config.api, true, true);
    freeze(config.api);
    freeze(config.api.$$list);
    ref3 = config.api.$$list;

    for (n = 0, len3 = ref3.length; n < len3; n++) {
      api = ref3[n];

      if (!noHelpers) {
        api.$$key = apiKey = "api.".concat(api.name);
      }

      api.methods = linkSortedMap(api.methods, false, true);
      freeze(api.methods);
      freeze(api.methods.$$list);
      ref4 = api.methods.$$list;

      for (o = 0, len4 = ref4.length; o < len4; o++) {
        method = ref4[o];

        if (!noHelpers) {
          method.$$key = "".concat(apiKey, ".method.").concat(method.name);
        }

        linkFieldsWithHelpers(method, 'arguments', "".concat(apiKey, ".method.").concat(method.name, ".arg"));
        linkFieldsWithHelpers(method, 'result', "".concat(apiKey, ".method.").concat(method.name, ".result"));
        freeze(method);
      }

      freeze(api);
    }

    return freeze(config); // link =
  }; // ----------------------------


  module.exports = link;
}).call(void 0);