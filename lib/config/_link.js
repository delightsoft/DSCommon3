"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var $$accessBuilder, $$calcBuilder, $$editValidateBuilder, $$fixBuilder, $$getBuilder, $$newBuilder, $$setBuilder, $$updateBuilder, $$validateBuilder, $$vueDebugWatchBuilderBuilder, $$wasTouchedBuilder, BitArray, Result, addValidate, hasOwnProperty, isResult, link, snakeCase, validateStructure;
  Result = require('../result');
  BitArray = require('../bitArray');
  hasOwnProperty = Object.prototype.hasOwnProperty;

  var _require = require('../utils/_err');

  isResult = _require.isResult;
  $$calcBuilder = require('./helpers/calc');
  $$fixBuilder = require('./helpers/fix');
  $$newBuilder = require('./helpers/new');
  $$getBuilder = require('./helpers/get');
  $$setBuilder = require('./helpers/set');
  $$updateBuilder = require('./helpers/update');
  $$wasTouchedBuilder = require('./helpers/wasTouched');
  $$vueDebugWatchBuilderBuilder = require('./helpers/vueDebugWatchBuilder');

  var _require2 = require('../validate');

  validateStructure = _require2.structure;
  addValidate = _require2.addValidate;
  $$accessBuilder = require('./helpers/access');
  $$validateBuilder = require('./helpers/validate');
  $$editValidateBuilder = require('./helpers/editValidate');
  snakeCase = require('lodash/snakeCase');

  link = function link(config, noHelpers, opts) {
    var EMPTY_FLAT_MAP, EMPTY_FLAT_MAP_TAGS, EMPTY_LIST, EMPTY_MAP, EMPTY_MAP_WITH_TAGS, EMPTY_MASK, EMPTY_MASK_WITH_TAGS, actions, api, apiKey, _deepFreeze, doc, docKey, freeze, freezeBitArray, j, l, len, len1, len2, len3, len4, linkFields, linkFieldsWithHelpers, linkFlatMap, linkSortedMap, linkTags, m, method, methods, n, o, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref27, ref28, ref29, ref3, ref30, ref31, ref32, ref33, ref34, ref4, ref5, ref6, ref7, ref8, ref9, state, transition;

    if (_typeof(noHelpers) === 'object' && noHelpers !== null) {
      methods = noHelpers;
      noHelpers = false;
    }

    freeze = function freeze(obj) {
      if (noHelpers) {
        return obj;
      }

      if (obj.hasOwnProperty('_mask')) {
        obj._buildList().lock();
      }

      return Object.freeze(obj);
    };

    _deepFreeze = function deepFreeze(obj) {
      var fld, fldName, results;
      freeze(obj);
      results = [];

      for (fldName in obj) {
        fld = obj[fldName];

        if (_typeof(fld) === 'object' && fld !== null) {
          results.push(_deepFreeze(fld));
        }
      }

      return results;
    };

    freezeBitArray = function freezeBitArray(ba) {
      ba.lock();
      return freeze(ba); // (ba) ->
    };

    EMPTY_LIST = freeze([]);
    EMPTY_MAP = {
      $$list: EMPTY_LIST
    };
    EMPTY_MASK = freezeBitArray(new BitArray(EMPTY_MAP));
    EMPTY_MAP.$$tags = freeze({
      all: EMPTY_MASK,
      none: EMPTY_MASK
    });
    freeze(EMPTY_MAP);
    EMPTY_MAP_WITH_TAGS = {
      $$list: EMPTY_LIST
    };
    EMPTY_MASK_WITH_TAGS = freezeBitArray(new BitArray(EMPTY_MAP_WITH_TAGS));
    EMPTY_MAP_WITH_TAGS.$$tags = freeze({
      all: EMPTY_MASK_WITH_TAGS,
      none: EMPTY_MASK_WITH_TAGS
    });
    freeze(EMPTY_MAP_WITH_TAGS);
    EMPTY_FLAT_MAP = {
      $$list: EMPTY_LIST,
      $$flat: freeze({
        $$list: EMPTY_LIST
      })
    };
    EMPTY_FLAT_MAP_TAGS = freezeBitArray(new BitArray(EMPTY_MAP_WITH_TAGS));
    EMPTY_FLAT_MAP.$$tags = freeze({
      all: EMPTY_FLAT_MAP_TAGS,
      none: EMPTY_FLAT_MAP_TAGS
    });
    freeze(EMPTY_FLAT_MAP);

    linkSortedMap = function linkSortedMap(collection, noIndex, noFreeze) {
      var i, j, len, ref, res, v;

      if (collection === void 0) {
        if (noIndex) {
          return EMPTY_MAP;
        } else {
          return EMPTY_MAP_WITH_TAGS;
        }
      }

      res = {};
      ref = collection.list;

      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        v = ref[i];

        if (!noIndex) {
          v.$$index = i;
        }

        res[v.name] = noFreeze ? v : freeze(v);

        if (v.hasOwnProperty('extra')) {
          _deepFreeze(v.extra);
        }
      }

      res.$$list = collection.list;

      if (collection.tags) {
        linkTags(res, collection);
      }

      if (noFreeze) {
        return res;
      } else {
        return freeze(res); // linkSortedMap =
      }
    };

    linkFlatMap = function linkFlatMap(collection, prop, noIndex, noMask, noFreeze) {
      var _linkLevel2, _buildMask, list, map, masks, res;

      if (collection === void 0) {
        return EMPTY_FLAT_MAP;
      }

      map = {};
      list = [];

      _linkLevel2 = function _linkLevel(level) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var j, len, v;

        for (j = 0, len = level.length; j < len; j++) {
          v = level[j];

          if (!noIndex) {
            v.$$index = list.length;
          }

          list.push(v);

          if (v.hasOwnProperty(prop)) {
            v[prop] = _linkLevel2(v[prop], "".concat(prefix).concat(v.name, "."));
          }

          map["".concat(prefix).concat(v.name)] = v;
        }

        return linkSortedMap({
          list: level
        }, true, prefix === '' || noFreeze); // _linkLevel
      };

      res = _linkLevel2(collection.list);
      (res.$$flat = map).$$list = freeze(list);
      freeze(map);

      if (collection.tags) {
        linkTags(res, collection);
      }

      if (!noMask) {
        masks = [];

        _buildMask = function buildMask(list) {
          var item, j, l, len, len1, mask, v;

          for (j = 0, len = list.length; j < len; j++) {
            item = list[j];

            for (l = 0, len1 = masks.length; l < len1; l++) {
              v = masks[l];
              v.set(item.$$index);
            }

            if (item.hasOwnProperty(prop)) {
              masks.push(item.$$mask = mask = new BitArray(res));

              _buildMask(item[prop].$$list);

              masks.pop(); // buildMask =
            }
          }
        };

        _buildMask(res.$$list);
      }

      if (noFreeze) {
        return res;
      } else {
        return freeze(res); // linkFlatMode =
      }
    };

    linkTags = function linkTags(res, collection) {
      var fld, j, k, len, ref, ref1, ref2, requiredMask, tags, v;
      tags = {
        all: freezeBitArray(new BitArray(res).invert()),
        none: freezeBitArray(new BitArray(res))
      };

      if (res.$$flat) {
        // only 'fields' are flatMap
        requiredMask = tags.required = new BitArray(res);
        ref = res.$$flat.$$list;

        for (j = 0, len = ref.length; j < len; j++) {
          fld = ref[j];

          if (fld.required) {
            requiredMask.set(fld.$$index);
          }
        }

        freezeBitArray(requiredMask);
      }

      ref1 = collection.tags;

      for (k in ref1) {
        v = ref1[k];
        tags[k] = freezeBitArray(new BitArray(((ref2 = res.$$flat) != null ? ref2.$$list : void 0) || res.$$list, v, res));
      }

      tags = res.$$tags = freeze(tags); // linkTags =
    };

    linkFieldsWithHelpers = function linkFieldsWithHelpers(obj, prop, prefix, isDoc) {
      var _assignKey, field, j, l, len, len1, ref, ref1;

      obj[prop] = linkFlatMap(obj[prop], 'fields', false, false, true);
      linkFields(config, obj[prop].$$flat.$$list);

      if (!noHelpers) {
        _assignKey = function assignKey(fields, levelPrefix) {
          var field, j, len, nextLevelPrefix, ref, results;
          ref = fields.$$list;
          results = [];

          for (j = 0, len = ref.length; j < len; j++) {
            field = ref[j];
            field.$$key = nextLevelPrefix = "".concat(levelPrefix, ".field.").concat(field.name);

            if (field.hasOwnProperty('udType')) {
              nextLevelPrefix = "type.".concat(field.udType[field.udType.length - 1]);
            }

            if (field.hasOwnProperty('fields')) {
              _assignKey(field.fields, nextLevelPrefix);
            }

            if (field.hasOwnProperty('enum')) {
              results.push(field["enum"].$$list.forEach(function (e) {
                e.$$key = "".concat(nextLevelPrefix, ".enum.").concat(e.name);
              }));
            } else {
              results.push(void 0);
            }
          }

          return results;
        };

        _assignKey(obj[prop], prefix);

        addValidate(obj[prop], obj[prop], methods != null ? methods.validators : void 0);
        ref = obj[prop].$$flat.$$list;

        for (j = 0, len = ref.length; j < len; j++) {
          field = ref[j];

          if (!~['structure', 'subtable'].indexOf(field.type)) {
            continue;
          }

          if (field.type === 'subtable') {
            field.fields.$$fix = $$fixBuilder(field.fields, obj[prop]);
            field.fields.$$new = $$newBuilder(field.fields);
            field.fields.$$get = $$getBuilder(field.fields);
            field.fields.$$set = $$setBuilder(field.fields);
          }

          field.fields.$$wasTouched = $$wasTouchedBuilder(field.fields);
        }

        obj[prop].$$calc = $$calcBuilder(obj[prop]);
        obj[prop].$$fix = $$fixBuilder(obj[prop], obj[prop]);
        obj[prop].$$new = $$newBuilder(obj[prop]);
        obj[prop].$$get = $$getBuilder(obj[prop]);
        obj[prop].$$set = $$setBuilder(obj[prop]);
        obj[prop].$$update = $$updateBuilder(obj);
        obj[prop].$$wasTouched = $$wasTouchedBuilder(obj[prop]);

        if (!(opts != null ? opts.server : void 0)) {
          obj[prop].$$vueDebugWatchBuilder = $$vueDebugWatchBuilderBuilder(obj[prop]);
        }
      }

      ref1 = obj[prop].$$flat.$$list;

      for (l = 0, len1 = ref1.length; l < len1; l++) {
        field = ref1[l];

        if ((opts != null ? opts.server : void 0) && isDoc) {
          field.$$field = snakeCase(field.name);
        }

        if (field.hasOwnProperty('enum')) {
          field["enum"].$$list.forEach(function (i) {
            freeze(i);
          });
        }

        if (field.hasOwnProperty('fields')) {
          freeze(field.fields);
        }

        freeze(field); // linkFieldsWithHelpers =
      }
    };

    linkFields = function linkFields(config, list) {
      var field, i, j, len, refName;

      for (j = 0, len = list.length; j < len; j++) {
        field = list[j];

        if (field.hasOwnProperty('udType')) {
          freeze(field.udType);
        }

        if (field.hasOwnProperty('refers')) {
          field.refers = function () {
            var l, len1, ref, results;
            ref = field.refers;
            results = [];

            for (l = 0, len1 = ref.length; l < len1; l++) {
              refName = ref[l];
              results.push(config.docs[refName]);
            }

            return results;
          }();
        }

        if (field.hasOwnProperty('enum')) {
          field["enum"] = linkSortedMap(field["enum"], true, true);
          freeze(field["enum"]);
          freeze(field["enum"].$$list);
        }

        if (field.hasOwnProperty('regexp')) {
          i = field.regexp.lastIndexOf('/');
          field.regexp = new RegExp(field.regexp.substr(1, i - 1), field.regexp.substr(i + 1)); // linkFields =
        }
      }
    };

    config.docs = linkSortedMap(config.docs, true, true);
    freeze(config.docs);
    freeze(config.docs.$$list);
    ref = config.docs.$$list;

    for (j = 0, len = ref.length; j < len; j++) {
      doc = ref[j];

      if (!noHelpers) {
        doc.$$key = docKey = doc.name;
      }

      if (opts && opts.server) {
        doc.$$table = snakeCase(doc.name);
      }

      linkFieldsWithHelpers(doc, 'fields', docKey, true);
      doc.actions = linkSortedMap(doc.actions, false, true);
      doc.actions.$$list.forEach(function (action) {
        if (action.arguments) {
          linkFieldsWithHelpers(action, 'arguments', "".concat(docKey, ".action.").concat(action.name, ".arg"));
        }

        if (action.result) {
          linkFieldsWithHelpers(action, 'result', "".concat(docKey, ".action.").concat(action.name, ".result"));
        }
      });
      doc.states = linkSortedMap(doc.states, true, true);

      if (!noHelpers) {
        actions = methods != null ? (ref1 = methods.docs) != null ? (ref2 = ref1[doc.name]) != null ? ref2.actions : void 0 : void 0 : void 0;
        doc.actions.$$list.forEach(function (action) {
          var code, ref3;
          action.$$key = "".concat(docKey, ".action.").concat(action.name);

          if (action.arguments) {
            action.arguments.$$access = $$accessBuilder(action, 'arguments', actions != null ? actions["".concat(action.name, "Access")] : void 0);
            action.arguments.$$validate = $$validateBuilder(action, 'arguments', actions != null ? actions["".concat(action.name, "Validate")] : void 0);
            action.arguments.$$editValidate = $$editValidateBuilder(action, 'arguments', action.arguments.$$access, actions != null ? actions["".concat(action.name, "Validate")] : void 0);
          }

          if (action.result) {
            action.result.$$access = $$accessBuilder(action, 'result', actions != null ? actions["".concat(action.name, "Access")] : void 0);
            action.result.$$validate = $$validateBuilder(action, 'result', actions != null ? actions["".concat(action.name, "Validate")] : void 0);
            action.result.$$editValidate = $$editValidateBuilder(action, 'result', action.result.$$access, actions != null ? actions["".concat(action.name, "Validate")] : void 0);
          }

          if (actions && (code = ((ref3 = actions["default"]) != null ? ref3[action.name] : void 0) || actions[action.name])) {
            action.$$code = code;
          }

          freeze(action);
        });
        doc.$$access = $$accessBuilder(doc, 'fields', methods != null ? (ref3 = methods.docs) != null ? (ref4 = ref3[doc.name]) != null ? ref4.access : void 0 : void 0 : void 0, true);
        doc.$$validate = $$validateBuilder(doc, 'fields', methods != null ? (ref5 = methods.docs) != null ? (ref6 = ref5[doc.name]) != null ? ref6.validate : void 0 : void 0 : void 0);
        doc.$$editValidate = $$editValidateBuilder(doc, 'fields', doc.$$access, methods != null ? (ref7 = methods.docs) != null ? (ref8 = ref7[doc.name]) != null ? ref8.validate : void 0 : void 0 : void 0);
        doc.fields.$$validate = $$validateBuilder(doc, 'fields', methods != null ? (ref9 = methods.docs) != null ? (ref10 = ref9[doc.name]) != null ? ref10.validate : void 0 : void 0 : void 0);
        doc.fields.$$editValidate = $$editValidateBuilder(doc, 'fields', doc.$$access, methods != null ? (ref11 = methods.docs) != null ? (ref12 = ref11[doc.name]) != null ? ref12.validate : void 0 : void 0 : void 0);
      }

      ref13 = doc.states.$$list;

      for (l = 0, len1 = ref13.length; l < len1; l++) {
        state = ref13[l];

        if (!noHelpers) {
          state.$$key = "".concat(docKey, ".state.").concat(state.name);
        }

        state.view = freezeBitArray(new BitArray(doc.fields.$$flat.$$list, state.view, doc.fields));
        state.update = freezeBitArray(new BitArray(doc.fields.$$flat.$$list, state.update, doc.fields));
        state.transitions = linkSortedMap(state.transitions, true, true);
        ref14 = state.transitions.$$list;

        for (m = 0, len2 = ref14.length; m < len2; m++) {
          transition = ref14[m];
          transition.next = doc.states[transition.next];
          freeze(transition);
        }

        freeze(state);
      }

      freeze(doc);
    }

    config.api = linkSortedMap(config.api, true, true);
    freeze(config.api);
    freeze(config.api.$$list);
    ref15 = config.api.$$list;

    for (n = 0, len3 = ref15.length; n < len3; n++) {
      api = ref15[n];

      if (!noHelpers) {
        api.$$key = apiKey = "api.".concat(api.name);
      }

      if (!api.methods) {
        api.methods = EMPTY_MAP_WITH_TAGS;
      } else {
        api.methods = linkSortedMap(api.methods, false, true);
        freeze(api.methods);
        freeze(api.methods.$$list);
        ref16 = api.methods.$$list;

        for (o = 0, len4 = ref16.length; o < len4; o++) {
          method = ref16[o];

          if (!noHelpers) {
            method.$$key = "".concat(apiKey, ".method.").concat(method.name);
          }

          linkFieldsWithHelpers(method, 'arguments', "".concat(apiKey, ".method.").concat(method.name, ".arg"));
          linkFieldsWithHelpers(method, 'result', "".concat(apiKey, ".method.").concat(method.name, ".result"));

          if (!noHelpers) {
            method.arguments.$$access = $$accessBuilder(method, 'arguments', methods != null ? (ref17 = methods.api) != null ? (ref18 = ref17[api.name]) != null ? (ref19 = ref18[method.name]) != null ? ref19.argAccess : void 0 : void 0 : void 0 : void 0);
            method.arguments.$$validate = $$validateBuilder(method, 'arguments', methods != null ? (ref20 = methods.api) != null ? (ref21 = ref20[api.name]) != null ? (ref22 = ref21[method.name]) != null ? ref22.argValidE : void 0 : void 0 : void 0 : void 0);
            method.arguments.$$editValidate = $$editValidateBuilder(method, 'arguments', method.arguments.$$access, methods != null ? (ref23 = methods.api) != null ? (ref24 = ref23[api.name]) != null ? (ref25 = ref24[method.name]) != null ? ref25.argValidate : void 0 : void 0 : void 0 : void 0);
            method.result.$$access = $$accessBuilder(method, 'result', methods != null ? (ref26 = methods.api) != null ? (ref27 = ref26[api.name]) != null ? (ref28 = ref27[method.name]) != null ? ref28.resultAccess : void 0 : void 0 : void 0 : void 0);
            method.result.$$validate = $$validateBuilder(method, 'result', methods != null ? (ref29 = methods.api) != null ? (ref30 = ref29[api.name]) != null ? (ref31 = ref30[method.name]) != null ? ref31.resultValidate : void 0 : void 0 : void 0 : void 0);
            method.result.$$editValidate = $$editValidateBuilder(method, 'result', method.arguments.$$access, methods != null ? (ref32 = methods.api) != null ? (ref33 = ref32[api.name]) != null ? (ref34 = ref33[method.name]) != null ? ref34.resultValidate : void 0 : void 0 : void 0 : void 0);
          }

          freeze(method);
        }
      }

      freeze(api);
    }

    return freeze(config); // link =
  }; // ----------------------------


  module.exports = link;
}).call(void 0);