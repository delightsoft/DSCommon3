"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var $$accessBuilder, $$applyUpdateBuilder, $$editValidateBuilderBuilder, $$fixBuilder, $$getBuilder, $$getUpdateBuilder, $$newBuilder, $$setBuilder, $$validateBuilder, BitArray, Result, addValidate, calc, hasOwnProperty, isResult, link, snakeCase, validateStructure;
  Result = require('../result');
  BitArray = require('../bitArray');
  calc = require('../tags/_calc');
  hasOwnProperty = Object.prototype.hasOwnProperty;

  var _require = require('../utils/_err');

  isResult = _require.isResult;
  $$fixBuilder = require('./helpers/fix');
  $$newBuilder = require('./helpers/new');
  $$getBuilder = require('./helpers/get');
  $$setBuilder = require('./helpers/set');

  var _require2 = require('../validate');

  validateStructure = _require2.structure;
  addValidate = _require2.addValidate;
  $$accessBuilder = require('./helpers/access');
  $$validateBuilder = require('./helpers/validate');
  $$editValidateBuilderBuilder = require('./helpers/editValidateBuilder');
  $$getUpdateBuilder = require('./helpers/getUpdate');
  $$applyUpdateBuilder = require('./helpers/applyUpdate');
  snakeCase = require('lodash/snakeCase');

  link = function link(config, noHelpers, opts) {
    var EMPTY_FLAT_MAP, EMPTY_LIST, EMPTY_MAP, EMPTY_MAP_WITH_TAGS, EMPTY_MASK, EMPTY_TAGS, actions, api, apiKey, _deepFreeze, doc, docKey, freeze, freezeBitArray, j, l, len, len1, len2, len3, len4, linkFields, linkFieldsWithHelpers, linkFlatMap, linkSortedMap, linkTags, m, method, methods, n, o, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref3, ref4, ref5, ref6, ref7, ref8, ref9, state, transition;

    if (_typeof(noHelpers) === 'object' && noHelpers !== null) {
      methods = noHelpers;
      noHelpers = false;
    }

    freeze = function freeze(obj) {
      if (noHelpers) {
        return obj;
      }

      if (obj.hasOwnProperty('_mask')) {
        obj.list; // force mask to compute list
      }

      return Object.freeze(obj);
    };

    _deepFreeze = function deepFreeze(obj) {
      var fld, fldName, results;
      freeze(obj);
      results = [];

      for (fldName in obj) {
        fld = obj[fldName];

        if (_typeof(fld) === 'object' && fld !== null) {
          results.push(_deepFreeze(fld));
        }
      }

      return results;
    };

    freezeBitArray = function freezeBitArray(ba) {
      ba.list;
      return freeze(ba); // (ba) ->
    };

    EMPTY_LIST = freeze([]);
    EMPTY_MAP_WITH_TAGS = freeze({
      $$list: EMPTY_LIST,
      $$tags: EMPTY_TAGS
    });
    EMPTY_MAP = freeze({
      $$list: EMPTY_LIST
    });
    EMPTY_MASK = freezeBitArray(new BitArray(EMPTY_MAP));
    EMPTY_TAGS = freeze({
      all: EMPTY_MASK,
      none: EMPTY_MASK
    });
    EMPTY_FLAT_MAP = freeze({
      $$list: EMPTY_LIST,
      $$flat: freeze({
        $$list: EMPTY_LIST
      }, {
        $$tags: EMPTY_TAGS
      })
    });
    EMPTY_MAP_WITH_TAGS = Object.freeze({
      $$list: [],
      $$tags: EMPTY_TAGS
    });

    linkSortedMap = function linkSortedMap(collection, noIndex, noFreeze) {
      var i, j, len, ref, res, v;

      if (collection === void 0) {
        if (noIndex) {
          return EMPTY_MAP;
        } else {
          return EMPTY_MAP_WITH_TAGS;
        }
      }

      res = {};
      ref = collection.list;

      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        v = ref[i];

        if (!noIndex) {
          v.$$index = i;
        }

        res[v.name] = noFreeze ? v : freeze(v);

        if (v.hasOwnProperty('extra')) {
          _deepFreeze(v.extra);
        }
      }

      res.$$list = collection.list;

      if (collection.tags) {
        linkTags(res, collection);
      }

      if (noFreeze) {
        return res;
      } else {
        return freeze(res); // linkSortedMap =
      }
    };

    linkFlatMap = function linkFlatMap(collection, prop, noIndex, noMask, noFreeze) {
      var _linkLevel2, _buildMask, list, map, masks, res;

      if (collection === void 0) {
        return EMPTY_FLAT_MAP;
      }

      map = {};
      list = [];

      _linkLevel2 = function _linkLevel(level) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var j, len, v;

        for (j = 0, len = level.length; j < len; j++) {
          v = level[j];

          if (!noIndex) {
            v.$$index = list.length;
          }

          list.push(v);

          if (v.hasOwnProperty(prop)) {
            v[prop] = _linkLevel2(v[prop], "".concat(prefix).concat(v.name, "."));
          }

          map["".concat(prefix).concat(v.name)] = v;
        }

        return linkSortedMap({
          list: level
        }, true, prefix === '' || noFreeze); // _linkLevel
      };

      res = _linkLevel2(collection.list);
      (res.$$flat = map).$$list = freeze(list);
      freeze(map);

      if (collection.tags) {
        linkTags(res, collection);
      }

      if (!noMask) {
        masks = [];

        _buildMask = function buildMask(list) {
          var item, j, l, len, len1, mask, v;

          for (j = 0, len = list.length; j < len; j++) {
            item = list[j];

            for (l = 0, len1 = masks.length; l < len1; l++) {
              v = masks[l];
              v.set(item.$$index);
            }

            if (item.hasOwnProperty(prop)) {
              masks.push(item.$$mask = mask = new BitArray(res));

              _buildMask(item[prop].$$list);

              masks.pop(); // buildMask =
            }
          }
        };

        _buildMask(res.$$list);
      }

      if (noFreeze) {
        return res;
      } else {
        return freeze(res); // linkFlatMode =
      }
    };

    linkTags = function linkTags(res, collection) {
      var cache, k, noCache, ref, ref1, tags, v;
      tags = {
        all: freezeBitArray(new BitArray(res).invert()),
        none: freezeBitArray(new BitArray(res))
      };
      ref = collection.tags;

      for (k in ref) {
        v = ref[k];
        tags[k] = freezeBitArray(new BitArray(((ref1 = res.$$flat) != null ? ref1.$$list : void 0) || res.$$list, v));
      }

      tags = res.$$tags = freeze(tags);

      if (!noHelpers) {
        cache = Object.create(null);

        noCache = function noCache(result, expr, options) {
          var localResult, r;

          if (!(_typeof(result) === 'object' && result !== null && result.hasOwnProperty('isError'))) {
            options = expr;
            expr = result;
            localResult = true;
            result = new Result();
          }

          r = calc(result, res, expr, options);

          if (localResult) {
            result.throwIfError();
          }

          return r; // noCache =
        };

        res.$$calc = function (result, expr, options) {
          var cacheExpr;
          cacheExpr = _typeof(result) === 'object' && result !== null && result.hasOwnProperty('isError') ? expr : result;

          if (hasOwnProperty.call(cache, cacheExpr)) {
            return cache[expr];
          }

          return cache[expr] = noCache(result, expr, options); // res.$$calc =
        };

        res.$$calc.noCache = noCache; // linkTags =
      }
    };

    linkFieldsWithHelpers = function linkFieldsWithHelpers(obj, prop, prefix, isDoc) {
      var _assignKey, field, j, l, len, len1, ref, ref1;

      obj[prop] = linkFlatMap(obj[prop], 'fields', false, false, true);
      linkFields(config, obj[prop].$$flat.$$list);

      if (!noHelpers) {
        _assignKey = function assignKey(fields, levelPrefix) {
          var field, j, len, nextLevelPrefix, ref, results;
          ref = fields.$$list;
          results = [];

          for (j = 0, len = ref.length; j < len; j++) {
            field = ref[j];
            field.$$key = nextLevelPrefix = "".concat(levelPrefix, ".field.").concat(field.name);

            if (field.hasOwnProperty('udType')) {
              nextLevelPrefix = "type.".concat(field.udType[field.udType.length - 1]);
            }

            if (field.hasOwnProperty('fields')) {
              _assignKey(field.fields, nextLevelPrefix);
            }

            if (field.hasOwnProperty('enum')) {
              results.push(field["enum"].$$list.forEach(function (e) {
                e.$$key = "".concat(nextLevelPrefix, ".enum.").concat(e.name);
              }));
            } else {
              results.push(void 0);
            }
          }

          return results;
        };

        _assignKey(obj[prop], prefix);

        addValidate(obj[prop], methods != null ? methods.validators : void 0);
        ref = obj[prop].$$flat.$$list;

        for (j = 0, len = ref.length; j < len; j++) {
          field = ref[j];

          if (!(field.type === 'subtable')) {
            continue;
          }

          field.fields.$$fix = $$fixBuilder(field.fields);
          field.fields.$$new = $$newBuilder(field.fields);
          field.fields.$$get = $$getBuilder(field.fields);
          field.fields.$$set = $$setBuilder(field.fields);
        }

        obj[prop].$$fix = $$fixBuilder(obj[prop]);
        obj[prop].$$new = $$newBuilder(obj[prop]);
        obj[prop].$$get = $$getBuilder(obj[prop]);
        obj[prop].$$set = $$setBuilder(obj[prop]);
      }

      ref1 = obj[prop].$$flat.$$list;

      for (l = 0, len1 = ref1.length; l < len1; l++) {
        field = ref1[l];

        if ((opts != null ? opts.server : void 0) && isDoc) {
          field.$$field = snakeCase(field.name);
        }

        if (field.hasOwnProperty('enum')) {
          field["enum"].$$list.forEach(function (i) {
            freeze(i);
          });
        }

        if (field.hasOwnProperty('fields')) {
          freeze(field.fields);
        }

        freeze(field); // linkFieldsWithHelpers =
      }
    };

    linkFields = function linkFields(config, list) {
      var field, i, j, len, refName;

      for (j = 0, len = list.length; j < len; j++) {
        field = list[j];

        if (field.hasOwnProperty('udType')) {
          freeze(field.udType);
        }

        if (field.hasOwnProperty('refers')) {
          field.refers = function () {
            var l, len1, ref, results;
            ref = field.refers;
            results = [];

            for (l = 0, len1 = ref.length; l < len1; l++) {
              refName = ref[l];
              results.push(config.docs[refName]);
            }

            return results;
          }();
        }

        if (field.hasOwnProperty('enum')) {
          field["enum"] = linkSortedMap(field["enum"], true, true);
          freeze(field["enum"]);
          freeze(field["enum"].$$list);
        }

        if (field.hasOwnProperty('regexp')) {
          i = field.regexp.lastIndexOf('/');
          field.regexp = new RegExp(field.regexp.substr(1, i - 1), field.regexp.substr(i + 1)); // linkFields =
        }
      }
    };

    config.docs = linkSortedMap(config.docs, true, true);
    freeze(config.docs);
    freeze(config.docs.$$list);
    ref = config.docs.$$list;

    for (j = 0, len = ref.length; j < len; j++) {
      doc = ref[j];

      if (!noHelpers) {
        doc.$$key = docKey = doc.name;
      }

      if (opts && opts.server) {
        doc.$$table = snakeCase(doc.name);
      }

      linkFieldsWithHelpers(doc, 'fields', docKey, true);
      doc.actions = linkSortedMap(doc.actions, false, true);
      doc.actions.$$list.forEach(function (action) {
        if (action.arguments) {
          linkFieldsWithHelpers(action, 'arguments');
        }
      });
      doc.states = linkSortedMap(doc.states, true, true);

      if (!noHelpers) {
        actions = methods != null ? (ref1 = methods.docs[doc.name]) != null ? ref1.actions : void 0 : void 0;
        doc.actions.$$list.forEach(function (action) {
          action.$$key = "".concat(docKey, ".action.").concat(action.name);

          if (actions && actions[action.name]) {
            action.$$code = actions[action.name];
          }

          freeze(action);
        });
        doc.$$access = $$accessBuilder(doc, 'fields', methods != null ? (ref2 = methods.docs[doc.name]) != null ? ref2.access : void 0 : void 0, true);
        doc.$$validate = $$validateBuilder(doc, 'fields', doc.$$access, methods != null ? (ref3 = methods.docs[doc.name]) != null ? ref3.validate : void 0 : void 0);
        doc.$$editValidateBuilder = $$editValidateBuilderBuilder(doc, 'fields', doc.$$access, methods != null ? (ref4 = methods.docs[doc.name]) != null ? ref4.validate : void 0 : void 0);
        doc.$$getUpdate = $$getUpdateBuilder(doc);
        doc.$$applyUpdate = $$applyUpdateBuilder(doc);
      }

      ref5 = doc.states.$$list;

      for (l = 0, len1 = ref5.length; l < len1; l++) {
        state = ref5[l];

        if (!noHelpers) {
          state.$$key = "".concat(docKey, ".state.").concat(state.name);
        }

        state.view = freezeBitArray(new BitArray(doc.fields.$$flat.$$list, state.view));
        state.update = freezeBitArray(new BitArray(doc.fields.$$flat.$$list, state.update));
        state.transitions = linkSortedMap(state.transitions, true, true);
        ref6 = state.transitions.$$list;

        for (m = 0, len2 = ref6.length; m < len2; m++) {
          transition = ref6[m];
          transition.next = doc.states[transition.next];
          freeze(transition);
        }

        freeze(state);
      }

      freeze(doc);
    }

    config.api = linkSortedMap(config.api, true, true);
    freeze(config.api);
    freeze(config.api.$$list);
    ref7 = config.api.$$list;

    for (n = 0, len3 = ref7.length; n < len3; n++) {
      api = ref7[n];

      if (!noHelpers) {
        api.$$key = apiKey = "api.".concat(api.name);
      }

      api.methods = linkSortedMap(api.methods, false, true);
      freeze(api.methods);
      freeze(api.methods.$$list);
      ref8 = api.methods.$$list;

      for (o = 0, len4 = ref8.length; o < len4; o++) {
        method = ref8[o];

        if (!noHelpers) {
          method.$$key = "".concat(apiKey, ".method.").concat(method.name);
        }

        linkFieldsWithHelpers(method, 'arguments', "".concat(apiKey, ".method.").concat(method.name, ".arg"));
        linkFieldsWithHelpers(method, 'result', "".concat(apiKey, ".method.").concat(method.name, ".result"));

        if (!noHelpers) {
          method.arguments.$$access = $$accessBuilder(method, 'arguments', methods != null ? (ref9 = methods.api) != null ? (ref10 = ref9[api.name]) != null ? (ref11 = ref10[method.name]) != null ? ref11.argAccess : void 0 : void 0 : void 0 : void 0);
          method.arguments.$$validate = $$validateBuilder(method, 'arguments', method.arguments.$$access, methods != null ? (ref12 = methods.api) != null ? (ref13 = ref12[api.name]) != null ? (ref14 = ref13[method.name]) != null ? ref14.argValidE : void 0 : void 0 : void 0 : void 0);
          method.arguments.$$editValidateBuilder = $$editValidateBuilderBuilder(method, 'arguments', method.arguments.$$access, methods != null ? (ref15 = methods.api) != null ? (ref16 = ref15[api.name]) != null ? (ref17 = ref16[method.name]) != null ? ref17.argValidate : void 0 : void 0 : void 0 : void 0);
          method.result.$$access = $$accessBuilder(method, 'result', methods != null ? (ref18 = methods.api) != null ? (ref19 = ref18[api.name]) != null ? (ref20 = ref19[method.name]) != null ? ref20.resultAccess : void 0 : void 0 : void 0 : void 0);
          method.result.$$validate = $$validateBuilder(method, 'result', method.result.$$access, methods != null ? (ref21 = methods.api) != null ? (ref22 = ref21[api.name]) != null ? (ref23 = ref22[method.name]) != null ? ref23.resultValidate : void 0 : void 0 : void 0 : void 0);
          method.result.$$editValidateBuilder = $$editValidateBuilderBuilder(method, 'result', method.arguments.$$access, methods != null ? (ref24 = methods.api) != null ? (ref25 = ref24[api.name]) != null ? (ref26 = ref25[method.name]) != null ? ref26.resultValidate : void 0 : void 0 : void 0 : void 0);
        }

        freeze(method);
      }

      freeze(api);
    }

    return freeze(config); // link =
  }; // ----------------------------


  module.exports = link;
}).call(void 0);