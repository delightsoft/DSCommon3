"use strict";

// Generated by CoffeeScript 2.5.1
(function () {
  var BitArray,
      EMPTY_FLAT_MAP,
      EMPTY_LIST,
      EMPTY_MAP,
      EMPTY_MAP_WITH_TAGS,
      EMPTY_MASK,
      EMPTY_TAGS,
      freeze,
      link,
      linkFields,
      linkFlatMap,
      linkSortedMap,
      linkTags,
      linkUDTypes,
      indexOf = [].indexOf;
  BitArray = require('../bitArray');

  freeze = function freeze(obj) {
    if (indexOf.call(obj, '_mask') >= 0) {
      obj.$$list; // force mask to compute list
    }

    return Object.freeze(obj);
  };

  EMPTY_LIST = freeze([]);
  EMPTY_MAP_WITH_TAGS = freeze({
    $$list: EMPTY_LIST,
    $$tags: EMPTY_TAGS
  });
  EMPTY_MAP = freeze({
    $$list: EMPTY_LIST
  });
  EMPTY_MASK = freeze(new BitArray(EMPTY_MAP));
  EMPTY_TAGS = freeze({
    all: EMPTY_MASK
  });
  EMPTY_FLAT_MAP = freeze({
    $$list: EMPTY_LIST,
    $$flat: freeze({
      $$list: EMPTY_LIST
    }, {
      $$tags: EMPTY_TAGS
    })
  });
  EMPTY_MAP_WITH_TAGS = Object.freeze({
    $$list: [],
    $$tags: EMPTY_TAGS
  });

  linkSortedMap = function linkSortedMap(collection, noIndex, noFreeze) {
    var i, j, len, ref, res, v;

    if (collection === void 0) {
      if (noIndex) {
        return EMPTY_MAP;
      } else {
        return EMPTY_MAP_WITH_TAGS;
      }
    }

    res = {};
    ref = collection.list;

    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      v = ref[i];
      res[v.name] = v;

      if (!noIndex) {
        v.$$index = i;
      }
    }

    res.$$list = collection.list;

    if (collection.tags) {
      res.$$tags = linkTags(res, collection);
    }

    if (noFreeze) {
      return res;
    } else {
      return freeze(res); // linkSortedMap =
    }
  };

  linkFlatMap = function linkFlatMap(collection, prop, noIndex, noMask) {
    var _linkLevel2, _buildMask, list, map, masks, res;

    if (collection === void 0) {
      return EMPTY_FLAT_MAP;
    }

    map = {};
    list = [];

    _linkLevel2 = function _linkLevel(level) {
      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var j, len, v;

      for (j = 0, len = level.length; j < len; j++) {
        v = level[j];

        if (!noIndex) {
          v.$$index = list.length;
        }

        list.push(v);

        if (v.hasOwnProperty(prop)) {
          v[prop] = _linkLevel2(v[prop], "".concat(prefix).concat(v.name, "."));
        }

        map["".concat(prefix).concat(v.name)] = v;
      }

      return linkSortedMap({
        list: level
      }, true, prefix === ''); // _linkLevel
    };

    res = _linkLevel2(collection.list);
    (res.$$flat = map).$$list = freeze(list);
    freeze(map);

    if (collection.tags) {
      linkTags(res, collection);
    }

    if (!noMask) {
      masks = [];

      _buildMask = function buildMask(list) {
        var item, j, l, len, len1, mask, v;

        for (j = 0, len = list.length; j < len; j++) {
          item = list[j];

          for (l = 0, len1 = masks.length; l < len1; l++) {
            v = masks[l];
            v.set(item.$$index);
          }

          if (item.hasOwnProperty(prop)) {
            masks.push(item.$$mask = mask = new BitArray(res));

            _buildMask(item[prop].$$list);

            masks.pop(); // buildMask =
          }
        }
      };

      _buildMask(res.$$list);
    }

    return freeze(res); // linkFlatMode =
  };

  linkTags = function linkTags(res, collection) {
    var k, ref, ref1, tags, v;
    tags = {
      all: freeze(new BitArray(res).invert())
    };
    ref = collection.tags;

    for (k in ref) {
      v = ref[k];
      tags[k] = freeze(new BitArray(((ref1 = res.$$flat) != null ? ref1.$$list : void 0) || res.$$list, v));
    }

    return res.$$tags = freeze(tags); // linkTags =
  };

  linkUDTypes = function linkUDTypes(config, list) {
    var j, len, refName, type;

    for (j = 0, len = list.length; j < len; j++) {
      type = list[j];

      if (type.hasOwnProperty('refers')) {
        // linkUDTypes =
        type.refers = function () {
          var l, len1, ref, results;
          ref = type.refers;
          results = [];

          for (l = 0, len1 = ref.length; l < len1; l++) {
            refName = ref[l];
            results.push(config.docs[refName]);
          }

          return results;
        }();
      }
    }
  };

  linkFields = function linkFields(config, list) {
    var field, j, len, refName, udt, udtList;

    for (j = 0, len = list.length; j < len; j++) {
      field = list[j];

      if (field.hasOwnProperty('udType')) {
        udt = config.udtypes[field.udType];
        udtList = [udt.name];

        while (udt.hasOwnProperty('udType')) {
          udt = config.udtypes[udt.udType];
          udtList.push(udt.name);
        }

        field.udType = freeze(udtList);
      }

      if (field.hasOwnProperty('refers')) {
        field.refers = function () {
          var l, len1, ref, results;
          ref = field.refers;
          results = [];

          for (l = 0, len1 = ref.length; l < len1; l++) {
            refName = ref[l];
            results.push(config.docs[refName]);
          }

          return results;
        }();
      }

      freeze(field); // linkFields =
    }
  };

  link = function link(config) {
    var api, doc, j, l, len, len1, len2, len3, len4, m, method, n, o, ref, ref1, ref2, ref3, ref4, state, transition;
    config.udtypes = linkSortedMap(config.udtypes, true);
    linkUDTypes(config, config.udtypes.$$list);
    config.docs = linkSortedMap(config.docs, true);
    ref = config.docs.$$list;

    for (j = 0, len = ref.length; j < len; j++) {
      doc = ref[j];
      doc.fields = linkFlatMap(doc.fields, 'fields');
      linkFields(config, doc.fields.$$flat.$$list);
      doc.actions = linkSortedMap(doc.actions);
      doc.states = linkSortedMap(doc.states, true);
      ref1 = doc.states.$$list;

      for (l = 0, len1 = ref1.length; l < len1; l++) {
        state = ref1[l];
        state.view = freeze(new BitArray(doc.fields.$$flat.$$list, state.view));
        state.update = freeze(new BitArray(doc.fields.$$flat.$$list, state.update));
        state.transitions = linkSortedMap(state.transitions, true);
        ref2 = state.transitions.$$list;

        for (m = 0, len2 = ref2.length; m < len2; m++) {
          transition = ref2[m];
          transition.next = doc.states[transition.next];
          freeze(transition);
        }

        freeze(state);
      }
    }

    config.api = linkSortedMap(config.api, true);
    ref3 = config.api.$$list;

    for (n = 0, len3 = ref3.length; n < len3; n++) {
      api = ref3[n];
      api.methods = linkSortedMap(api.methods);
      ref4 = api.methods.$$list;

      for (o = 0, len4 = ref4.length; o < len4; o++) {
        method = ref4[o];
        method.arguments = linkFlatMap(method.arguments, 'fields');
        linkFields(config, method.arguments.$$flat.$$list);
        method.result = linkFlatMap(method.result, 'fields');
        linkFields(config, method.result.$$flat.$$list);
        freeze(method);
      }

      freeze(api);
    }

    return config; // link =
  }; // ----------------------------


  module.exports = link;
}).call(void 0);