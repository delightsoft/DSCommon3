"use strict";

// Generated by CoffeeScript 2.5.1
(function () {
  var Result, builtInTypes, checkUDTypeName, compileType, copyExtra, extraProps, processUdtypes, reservedTypes, sortedMap, typeProps;
  Result = require('../result');

  var _require = require('../utils');

  checkUDTypeName = _require.checkUDTypeName;
  sortedMap = require('../sortedMap');
  copyExtra = require('./_copyExtra');

  var _require2 = require('../types');

  compileType = _require2.compile;
  var _require2$compile = _require2.compile;
  builtInTypes = _require2$compile._builtInTypes;
  reservedTypes = _require2$compile._reservedTypes;
  typeProps = _require2$compile._typeProps;
  extraProps = _require2$compile._extraProps;

  processUdtypes = function processUdtypes(result, config) {
    if (!config.$$src.udtypes) {
      config.udtypes = {
        $$list: []
      };
      return;
    }

    return result.context(Result.prop('udtypes'), function () {
      // processUdtypes =
      var cycledTypes, i, item, j, len, len1, _processUdtype, ref, ref1, res, udType, udt;

      res = sortedMap(result, config.$$src.udtypes, {
        checkName: checkUDTypeName
      });

      if (result.isError) {
        return;
      }

      ref = res.$$list;

      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];

        if (item.$$src.fields) {
          item.fields = item.$$src.fields;
        }
      }

      copyExtra(result, res);
      udType = void 0;
      result.context(function (path) {
        return Result.prop(udType.name)(path);
      }, function () {
        var j, k, l, len1, len2, len3, ref1, results, t;

        for (j = 0, len1 = builtInTypes.length; j < len1; j++) {
          t = builtInTypes[j];

          if (!res.hasOwnProperty(t)) {
            continue;
          }

          udType = res[t];
          result.error('dsc.builtInTypeName');
        }

        for (k = 0, len2 = reservedTypes.length; k < len2; k++) {
          t = reservedTypes[k];

          if (!res.hasOwnProperty(t)) {
            continue;
          }

          udType = res[t];
          result.error('dsc.reservedTypeName');
        }

        if (!result.isError) {
          ref1 = res.$$list;
          results = [];

          for (l = 0, len3 = ref1.length; l < len3; l++) {
            udType = ref1[l];
            results.push(compileType(result, udType.$$src, udType, {
              context: 'udtype'
            }));
          }

          return results;
        }
      });

      if (result.isError) {
        return;
      }

      cycledTypes = [];

      _processUdtype = function processUdtype(udt, stack) {
        // recurrent types processing
        var j, k, l, len1, len2, len3, parent, prop, src, t;

        if (stack && stack.indexOf(udt.name) >= 0) {
          if (!cycledTypes.hasOwnProperty(udt.name)) {
            result.error('dsc.cycledUdtypes', {
              value: stack
            });

            for (j = 0, len1 = stack.length; j < len1; j++) {
              t = stack[j];
              cycledTypes[t] = true;
            }
          }

          return;
        }

        if (!udt.hasOwnProperty('type')) {
          if (!res.hasOwnProperty(udt.udType)) {
            result.error({
              code: 'dsc.unknownType',
              value: udt.udType
            });
            return;
          }

          parent = res[udt.udType];

          if (!parent.hasOwnProperty('type')) {
            _processUdtype(parent, stack ? (stack.push(udt.name), stack) : [udt.name]);
          }

          if (parent.hasOwnProperty('type')) {
            // processed successfully
            src = Object.assign({}, parent);
            delete src.udType; // derive type props

            for (k = 0, len2 = typeProps.length; k < len2; k++) {
              prop = typeProps[k];

              if (udt.$$src.hasOwnProperty(prop)) {
                src[prop] = udt.$$src[prop];
              }
            } // derive type props


            for (l = 0, len3 = extraProps.length; l < len3; l++) {
              prop = extraProps[l];

              if (udt.$$src.hasOwnProperty(prop)) {
                src[prop] = udt.$$src[prop];
              }
            }

            for (prop in udt) {
              if (!~['name', 'extra'].indexOf(prop)) {
                delete udt[prop];
              }
            }

            if (src.fields) {
              udt.fields = src.fields;
            }

            compileType(result, src, udt, {
              context: 'udtype' // перекомпилируем, на случай если переопределены свойства базового типа

            });
            udt.udType = parent.name;

            if (parent.hasOwnProperty('extra')) {
              if (udt.hasOwnProperty('extra')) {
                return udt.extra = Object.assign({}, parent.extra, udt.extra);
              } else {
                return udt.extra = parent.extra;
              }
            }
          }
        }
      };

      ref1 = res.$$list;

      for (j = 0, len1 = ref1.length; j < len1; j++) {
        udt = ref1[j];

        _processUdtype(udt);
      }

      if (!result.isError) {
        copyExtra(result, res);
        config.udtypes = result.isError ? 'failed' : res; // processUdtypes = (result, config) ->
      }
    });
  }; // ----------------------------


  module.exports = processUdtypes;
}).call(void 0);