"use strict";

// Generated by CoffeeScript 2.5.1
(function () {
  var Result, builtInTypes, compileType, processUdtypes, reservedTypes, sortedMap, typeProps;
  Result = require('../result');
  sortedMap = require('../sortedMap');

  var _require = require('../types');

  compileType = _require.compile;
  var _require$compile = _require.compile;
  builtInTypes = _require$compile._builtInTypes;
  reservedTypes = _require$compile._reservedTypes;
  typeProps = _require$compile._typeProps;

  processUdtypes = function processUdtypes(result, config) {
    if (!config.$$src.hasOwnProperty('udtypes')) {
      config.udtypes = {
        $$list: []
      };
      return;
    }

    return result.context(Result.prop('udtypes'), function () {
      // processUdtypes =
      var cycledTypes, i, len, _processUdtype, ref, res, udType, udt;

      res = sortedMap(result, config.$$src.udtypes);

      if (result.isError) {
        return;
      }

      udType = void 0;
      result.context(function (path) {
        return Result.item(udType.name)(path);
      }, function () {
        var i, j, k, len, len1, len2, ref, results, t;

        for (i = 0, len = builtInTypes.length; i < len; i++) {
          t = builtInTypes[i];

          if (!res.hasOwnProperty(t)) {
            continue;
          }

          udType = res[t];
          result.error('dsc.builtInTypeName');
        }

        for (j = 0, len1 = reservedTypes.length; j < len1; j++) {
          t = reservedTypes[j];

          if (!res.hasOwnProperty(t)) {
            continue;
          }

          udType = res[t];
          result.error('dsc.reservedTypeName');
        }

        if (!result.isError) {
          ref = res.$$list;
          results = [];

          for (k = 0, len2 = ref.length; k < len2; k++) {
            udType = ref[k];
            results.push(compileType(result, udType.$$src, udType, {
              context: 'udtype'
            }));
          }

          return results;
        }
      });

      if (result.isError) {
        return;
      }

      cycledTypes = [];

      _processUdtype = function processUdtype(udt, stack) {
        // recurrent types processing
        var i, j, len, len1, parent, prop, results, t;

        if (stack && stack.indexOf(udt.name) >= 0) {
          if (!cycledTypes.hasOwnProperty(udt.name)) {
            result.error('dsc.cycledUdtypes', {
              value: stack
            });

            for (i = 0, len = stack.length; i < len; i++) {
              t = stack[i];
              cycledTypes[t] = true;
            }
          }

          return;
        }

        if (!udt.hasOwnProperty('type')) {
          if (!res.hasOwnProperty(udt.udType)) {
            result.error({
              code: 'dsc.unknownType',
              value: udt.udType
            });
          }

          parent = res[udt.udType];

          if (!parent.hasOwnProperty('type')) {
            _processUdtype(parent, stack ? (stack.push(udt.name), stack) : [udt.name]);
          }

          if (parent.hasOwnProperty('type')) {
            // processed successfully
            udt.type = parent.type;
            udt.udType = parent.name; // derive type props

            results = [];

            for (j = 0, len1 = typeProps.length; j < len1; j++) {
              prop = typeProps[j];

              if (parent.hasOwnProperty(prop)) {
                results.push(udt[prop] = parent[prop]);
              }
            }

            return results;
          }
        }
      };

      ref = res.$$list;

      for (i = 0, len = ref.length; i < len; i++) {
        udt = ref[i];

        _processUdtype(udt);
      }

      if (!result.isError) {
        sortedMap.finish(result, res);
        config.udtypes = result.isError ? 'failed' : res; // processUdtypes = (result, config) ->
      }
    });
  }; // ----------------------------


  module.exports = processUdtypes;
}).call(void 0);