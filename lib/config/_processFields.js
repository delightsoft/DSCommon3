"use strict";

// Generated by CoffeeScript 2.5.1
(function () {
  var Result, compileTags, compileType, copyExtra, extraProps, flatMap, processCustomValidate, processFields, typeProps;
  Result = require('../result');
  flatMap = require('../flatMap');
  copyExtra = require('./_copyExtra');

  var _require = require('../types');

  compileType = _require.compile;
  var _require$compile = _require.compile;
  typeProps = _require$compile._typeProps;
  extraProps = _require$compile._extraProps;

  var _require2 = require('../tags');

  compileTags = _require2.compile;
  processCustomValidate = require('../validate/processCustomValidate');

  processFields = function processFields(result, doc, config) {
    var fieldsProp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'fields';
    var noSystemItems = arguments.length > 4 ? arguments[4] : undefined;

    if (!doc.$$src.hasOwnProperty(fieldsProp)) {
      result.error('dsc.missingProp', {
        value: fieldsProp
      });
      return;
    }

    return result.context(Result.prop(fieldsProp), function () {
      // processFields
      var _processLevel2, flatMapOpts, res;

      flatMapOpts = {
        index: true,
        mask: true
      };

      if (!noSystemItems) {
        flatMapOpts.before = [{
          name: 'id',
          type: 'nanoid',
          tags: 'field, system, index, unique'
        }, {
          name: 'rev',
          type: 'int',
          init: 0,
          tags: 'field, system'
        }];
        flatMapOpts.after = [{
          name: 'options',
          type: 'json',
          tags: 'field, system, index'
        }, {
          name: 'created',
          type: 'timestamp',
          tags: 'field, system, index'
        }, {
          name: 'modified',
          type: 'timestamp',
          tags: 'field, system, index'
        }, {
          name: 'deleted',
          type: 'boolean',
          init: false,
          tags: 'field, system'
        }];

        if (doc.$$src.states) {
          flatMapOpts.after.unshift({
            name: 'state',
            type: 'string(100)',
            init: 'new',
            tags: 'field, system, index'
          });
        }

        flatMapOpts.reservedNames = ['id', 'rev', 'state', 'options', 'created', 'modified', 'deleted'];
      }

      res = flatMap(result, doc.$$src[fieldsProp], 'fields', flatMapOpts);

      if (!result.isError) {
        _processLevel2 = function _processLevel(level) {
          var field;
          copyExtra(result, level);
          field = void 0;
          result.context(function (path) {
            return Result.prop(field.name)(path);
          }, function () {
            var i, j, k, len, len1, len2, parentUdt, prop, ref, ref1, src, udt, udtList;
            ref = level.$$list;

            for (i = 0, len = ref.length; i < len; i++) {
              field = ref[i];
              result.isError = false;
              compileType(result, field.$$src, field, {
                context: 'field'
              });

              if (field.hasOwnProperty('udType') && config.udtypes !== 'failed') {
                if (!(config.udtypes && config.udtypes.hasOwnProperty(field.udType))) {
                  result.error('dsc.unknownType', {
                    value: field.udType
                  });
                } else {
                  udt = config.udtypes[field.udType];
                  src = Object.assign({}, udt);
                  delete src.udType; // derive type props

                  for (j = 0, len1 = typeProps.length; j < len1; j++) {
                    prop = typeProps[j];

                    if (field.$$src.hasOwnProperty(prop)) {
                      src[prop] = field.$$src[prop];
                    }
                  } // derive type props


                  for (k = 0, len2 = extraProps.length; k < len2; k++) {
                    prop = extraProps[k];

                    if (field.$$src.hasOwnProperty(prop)) {
                      src[prop] = field.$$src[prop];
                    }
                  }

                  for (prop in field) {
                    if (!~['name', 'extra'].indexOf(prop) && !prop.startsWith('$$')) {
                      delete field[prop];
                    }
                  }

                  compileType(result, src, field, {
                    context: 'field' // перекомпилируем, на случай если переопределены свойства базового типа

                  });
                  udtList = [udt.name];
                  parentUdt = udt;

                  while (parentUdt.hasOwnProperty('udType')) {
                    parentUdt = config.udtypes[parentUdt.udType];
                    udtList.push(parentUdt.name);
                  }

                  field.udType = udtList;

                  if (udt.hasOwnProperty('extra')) {
                    if (field.hasOwnProperty('extra')) {
                      field.extra = Object.assign({}, udt.extra, field.extra);
                    } else {
                      field.extra = udt.extra;
                    }
                  }
                }
              }

              if (!result.isError) {
                if (field.hasOwnProperty('fields')) {
                  result.context(Result.prop('fields'), function () {
                    return _processLevel2(field.fields);
                  });
                }
              }

              if (processCustomValidate(result, field.$$src, level, (ref1 = config.$$src) != null ? ref1.validators : void 0)) {
                // result.context
                // _processLevel =
                field.validate = field.$$src.validate;
              }
            }
          });
        };

        _processLevel2(res);

        compileTags(result, res);
        flatMap.finish(result, res, 'fields', {
          skipProps: ['tags', 'required', 'null']
        });

        if (!result.isError) {
          // result.context
          return res;
        }
      }
    });
  }; // ----------------------------


  module.exports = processFields;
}).call(void 0);