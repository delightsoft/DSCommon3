"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var $$editValidatorBuilder, Result, cloneDeep, invalidArg, unknownOption;
  Result = require('../../result');
  cloneDeep = require('lodash/cloneDeep');

  var _require = require('../../utils/_err');

  invalidArg = _require.invalidArg;
  unknownOption = _require.unknownOption;

  $$editValidatorBuilder = function $$editValidatorBuilder(type, fieldsProp, access, docLevelValidate) {
    var typeDesc;
    typeDesc = type.$$access === access ? type : type[fieldsProp];
    return function (fields, options) {
      var beforeAction, beforeSave, goodForAction, localResult, messages, optName, optValue, r, save, validate;
      beforeSave = false;
      beforeAction = false;

      if (options !== void 0) {
        if (!(_typeof(options) === 'object' && options !== null && !Array.isArray(options))) {
          invalidArg('options', options);
        }

        for (optName in options) {
          optValue = options[optName];

          switch (optName) {
            case 'beforeSave':
              beforeSave = !!optValue;
              break;

            case 'beforeAction':
              beforeAction = !!optValue;
              break;

            default:
              unknownOption(optName);
          }
        }
      }

      validate = type["_".concat(fieldsProp, "Validate")];
      messages = {};
      r = access.call(typeDesc, fields);
      save = true;
      goodForAction = beforeAction;
      localResult = new Result();

      localResult.error = function () {
        // перехватываем сообщения об ошибках
        var msg;
        msg = Result.prototype.error.apply(localResult, arguments);

        if (msg.type === 'error') {
          goodForAction = false;

          if (msg.code === 'validate.invalidValue') {
            // localResult.error = () ->
            save = false;
          }
        }
      };

      validate(localResult, fields, void 0, fields, r.update, r.required, beforeSave || beforeAction ? void 0 : fields.$$touched, false, beforeAction);

      if (!localResult.isError) {
        if (docLevelValidate != null) {
          docLevelValidate.call(type, localResult, fields);
        }
      }

      localResult.messages.forEach(function (msg) {
        var path;

        if (path = msg.path) {
          !messages[path] || msg.type === 'error' && messages[path].type !== 'error' ? messages[path] = msg : void 0;
        } else {
          (messages[''] || (messages[''] = [])).push(msg);
        }
      });
      return {
        save: save,
        goodForAction: goodForAction,
        messages: messages
      }; // (fields) ->  # ->
    };
  }; // ----------------------------


  module.exports = $$editValidatorBuilder;
}).call(void 0);