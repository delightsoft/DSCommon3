"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var _$$fixBuilder, EMPTY, defaultInit, hasOwnProperty, invalidArg, invalidOption, unknownOption;

  var _require = require('../../utils/_err');

  invalidArg = _require.invalidArg;
  invalidOption = _require.invalidOption;
  unknownOption = _require.unknownOption;
  defaultInit = {
    string: '',
    text: '',
    "boolean": false,
    integer: 0,
    "double": 0,
    //  decimal: '0'
    time: null,
    date: null,
    timestamp: null
  }; //  json:
  //  blob:
  //  uuid:
  //  enum:

  EMPTY = {};
  hasOwnProperty = Object.prototype.hasOwnProperty;

  _$$fixBuilder = function $$fixBuilder(fields) {
    var field, fixFuncs, i, len, ref;
    fixFuncs = [];
    ref = fields.$$list;

    for (i = 0, len = ref.length; i < len; i++) {
      field = ref[i];

      (function () {
        var copyVal, fix, index, init, initVal, name;
        name = field.name;
        init = void 0;
        index = field.$$index;

        if (field.type === 'structure') {
          init = _$$fixBuilder(field.fields);
        } else if (field.type === 'subtable') {
          if (field.required) {
            (function (fields) {
              init = function init(options) {
                return [fields.$$fix(EMPTY, options)];
              };
            })(field.fields);
          } else {
            init = [];
          }
        } else if (field.hasOwnProperty('init')) {
          init = field.init;
        } else if (field["null"]) {
          init = null;
        } else if (defaultInit.hasOwnProperty(field.type)) {
          init = defaultInit[field.type];
        } else if (field.type === 'enum') {
          init = field["enum"].$$list[0].name;
        } else {
          init = null;
        }

        if (typeof init === 'function') {
          initVal = function initVal(res, options) {
            res[name] = init(options);
          };
        } else {
          initVal = function initVal(res) {
            res[name] = init;
          };
        }

        if (field.type === 'structure') {
          fix = _$$fixBuilder(field.fields);

          copyVal = function copyVal(res, fieldsLevel, options) {
            var update;
            update = options.update;
            res[name] = fix(fieldsLevel[name], update ? Object.assign({}, options, {
              update: update[name]
            }) : options);
          };
        } else if (field.type === 'subtable') {
          fix = field.fields.$$fix;

          copyVal = function copyVal(res, fieldsLevel, options) {
            var opts, row, update;
            update = options.update;
            opts = update ? Object.assign({}, options, {
              update: update[name]
            }) : options;

            res[name] = function () {
              var j, len1, ref1, results;
              ref1 = fieldsLevel[name];
              results = [];

              for (j = 0, len1 = ref1.length; j < len1; j++) {
                row = ref1[j];
                results.push(fix(row, opts));
              }

              return results;
            }();
          };
        } else {
          copyVal = function copyVal(res, fieldsLevel) {
            return res[name] = fieldsLevel[name];
          };
        }

        return fixFuncs.push(function (res, fieldsLevel, mask, update, newVal, options) {
          if (!mask || mask.get(index)) {
            if (update && hasOwnProperty.call(update, name)) {
              return copyVal(res, update, options);
            } else if (hasOwnProperty.call(fieldsLevel, name)) {
              return copyVal(res, fieldsLevel, options);
            } else {
              if (newVal) {
                return initVal(res, options);
              }
            }
          }
        });
      })();
    }

    return function (fieldsLevel, options) {
      var edit, mask, newVal, optName, optValue, res, update;
      edit = false;
      mask = void 0;
      update = void 0;
      newVal = true;

      if (options !== void 0) {
        if (!(_typeof(options) === 'object' && options !== null && !Array.isArray(options))) {
          invalidArg('options', options);
        }

        for (optName in options) {
          optValue = options[optName];

          switch (optName) {
            // TODO: check options type
            case 'edit':
              if (!(optValue === void 0 || typeof optValue === 'boolean')) {
                invalidOption('edit', optValue);
              }

              edit = optValue;
              break;

            case 'mask':
              if (!(optValue === void 0 || _typeof(optValue) === 'object' && optValue !== null && optValue._collection !== fields)) {
                invalidOption('mask', optValue);
              }

              mask = optValue;
              break;

            case 'update':
              if (!(optValue === void 0 || _typeof(optValue) === 'object' && optValue !== null && Array.isArray(optValue))) {
                invalidOption('update', optValue);
              }

              update = optValue;
              break;

            case 'newVal':
              if (!(optValue === void 0 || typeof optValue === 'boolean')) {
                invalidOption('newVal', optValue);
              }

              newVal = optValue;
              break;

            default:
              unknownOption(optName);
          }
        }
      }

      res = {};
      fixFuncs.forEach(function (f) {
        f(res, fieldsLevel, mask, update, newVal, options);
      });

      if (edit) {
        res.$$touched = {};
      }

      return res; // () ->
    };
  }; // ----------------------------


  module.exports = _$$fixBuilder;
}).call(void 0);