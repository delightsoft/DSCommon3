"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var _$$fixBuilder, EMPTY, defaultInit, hasOwnProperty, invalidArg, invalidOption, moment, unknownOption;

  var _require = require('../../utils/_err');

  invalidArg = _require.invalidArg;
  invalidOption = _require.invalidOption;
  unknownOption = _require.unknownOption;
  moment = require('moment');
  defaultInit = {
    string: '',
    text: '',
    "boolean": false,
    integer: 0,
    "double": 0,
    //  decimal: '0'
    time: null,
    date: null,
    timestamp: null
  }; //  json:
  //  blob:
  //  uuid:
  //  enum:

  EMPTY = {};
  hasOwnProperty = Object.prototype.hasOwnProperty;

  _$$fixBuilder = function $$fixBuilder(fields) {
    var field, fixFuncs, j, len, ref;
    fixFuncs = [];
    ref = fields.$$list;

    for (j = 0, len = ref.length; j < len; j++) {
      field = ref[j];

      (function () {
        var copyVal, fix, index, init, initVal, name;
        name = field.name;
        init = void 0;
        index = field.$$index;

        if (field.type === 'structure') {
          init = _$$fixBuilder(field.fields);
        } else if (field.type === 'subtable') {
          if (field.required) {
            (function (fields) {
              init = function init(options) {
                return [fields.$$fix(EMPTY, options)];
              };
            })(field.fields);
          } else {
            init = [];
          }
        } else if (field.hasOwnProperty('init')) {
          init = field.init;
        } else if (field["null"]) {
          init = null;
        } else if (defaultInit.hasOwnProperty(field.type)) {
          init = defaultInit[field.type];
        } else if (field.type === 'enum') {
          init = field["enum"].$$list[0].name;
        } else {
          init = null;
        }

        if (typeof init === 'function') {
          initVal = function initVal(res, options) {
            res[name] = init(options);
          };
        } else {
          initVal = function initVal(res) {
            res[name] = init;
          };
        }

        if (field.type === 'structure') {
          fix = _$$fixBuilder(field.fields);

          copyVal = function copyVal(res, update, options, fieldsLevel) {
            if (fieldsLevel && fieldsLevel.hasOwnProperty(name)) {
              res[name] = fix(fieldsLevel[name], update ? Object.assign({}, options, {
                update: update[name]
              }) : options);
            } else {
              res[name] = fix(update[name], Object.assign({}, options, {
                update: void 0
              }));
            }
          };
        } else if (field.type === 'subtable') {
          fix = field.fields.$$fix;

          copyVal = function copyVal(res, update, options, fieldsLevel, copyIndex) {
            var i, k, len1, opts, r, ref1, row, src;
            opts = Object.assign({}, options, {
              update: void 0
            });

            res[name] = function () {
              var k, l, len1, len2, ref1, ref2, ref3, results, results1;

              if (fieldsLevel && fieldsLevel.hasOwnProperty(name)) {
                src = fieldsLevel[name];
                ref1 = update[name];
                results = [];

                for (k = 0, len1 = ref1.length; k < len1; k++) {
                  row = ref1[k];

                  if (Number.isInteger(row._i) && 0 <= (ref2 = row._i) && ref2 < src.length) {
                    results.push(fix(src[row._i], Object.assign({}, options, {
                      update: row
                    })));
                  } else {
                    results.push(fix(row, opts));
                  }
                }

                return results;
              } else {
                ref3 = update[name];
                results1 = [];

                for (l = 0, len2 = ref3.length; l < len2; l++) {
                  row = ref3[l];
                  r = fix(row, opts);

                  if (copyIndex && row.hasOwnProperty('_i') && !options.noIndex) {
                    r._i = row._i;
                  }

                  results1.push(r);
                }

                return results1;
              }
            }();

            if (options.edit) {
              ref1 = res[name];

              for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
                row = ref1[i];
                row._i = i;
              }
            }
          };
        } else {
          copyVal = function () {
            switch (field.type) {
              case 'date':
                return function (res, fieldsLevel) {
                  res[name] = moment(fieldsLevel[name]).format('YYYY-MM-DD');
                };

              case 'time':
                return function (res, fieldsLevel) {
                  res[name] = "".concat(moment(fieldsLevel[name]).utc().format('HH:mm:ss.SSS'), "Z");
                };

              case 'timestamp':
                return function (res, fieldsLevel) {
                  res[name] = "".concat(moment(fieldsLevel[name]).utc().format('YYYY-MM-DDTHH:mm:ss.SSS'), "Z");
                };

              default:
                return function (res, fieldsLevel) {
                  return res[name] = fieldsLevel[name];
                };
            }
          }();
        }

        return fixFuncs.push(function (res, fieldsLevel, mask, update, newVal, options) {
          if (!mask || mask.get(index)) {
            if (update && hasOwnProperty.call(update, name)) {
              return copyVal(res, update, options, fieldsLevel);
            } else if (hasOwnProperty.call(fieldsLevel, name)) {
              return copyVal(res, fieldsLevel, options, void 0, true);
            } else {
              if (newVal) {
                return initVal(res, options);
              }
            }
          }
        });
      })();
    }

    return function (fieldsLevel, options) {
      var edit, mask, newVal, optName, optValue, res, update;
      edit = false;
      mask = void 0;
      update = void 0;
      newVal = true;

      if (options !== void 0) {
        if (!(_typeof(options) === 'object' && options !== null && !Array.isArray(options))) {
          invalidArg('options', options);
        }

        for (optName in options) {
          optValue = options[optName];

          switch (optName) {
            case 'edit':
              // true, добавить в результат $$touched и _i в строках subtable
              if (!(optValue === void 0 || typeof optValue === 'boolean')) {
                invalidOption('edit', optValue);
              }

              if (optValue !== void 0) {
                edit = optValue;
              }

              break;

            case 'mask':
              // маска полей, которые надо оставить в результате (по умолчанию undefined - все поля)
              if (!(optValue === void 0 || _typeof(optValue) === 'object' && optValue !== null && optValue._collection !== fields)) {
                invalidOption('mask', optValue);
              }

              mask = optValue;
              break;

            case 'update':
              // обновление накладываемле поверх данных (по умолчанию undefined)
              if (!(optValue === void 0 || _typeof(optValue) === 'object' && optValue !== null && !Array.isArray(optValue))) {
                invalidOption('update', optValue);
              }

              update = optValue;
              break;

            case 'newVal':
              // true, создавать недостающие поля с начальными значениями (по умолчанию true)
              if (!(optValue === void 0 || typeof optValue === 'boolean')) {
                invalidOption('newVal', optValue);
              }

              if (optValue !== void 0) {
                newVal = optValue;
              }

              break;

            case 'noIndex':
              // true, не копировать свойство _i в строках subtable (по умолчанию false)
              if (!(optValue === void 0 || typeof optValue === 'boolean')) {
                invalidOption('noIndex', optValue);
              }

              break;

            default:
              unknownOption(optName);
          }
        }
      }

      res = {};
      fixFuncs.forEach(function (f) {
        f(res, fieldsLevel, mask, update, newVal, options);
      });

      if (edit) {
        res.$$touched = {};
      }

      return res; // () ->
    };
  }; // ----------------------------


  module.exports = _$$fixBuilder;
}).call(void 0);