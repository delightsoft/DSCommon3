"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var $$validateBuilder, Result, unknownOption, validateStructure;
  Result = require('../../result');

  var _require = require('../../utils/_err');

  unknownOption = _require.unknownOption;

  var _require2 = require('../../validate');

  validateStructure = _require2.structure;

  $$validateBuilder = function $$validateBuilder(type, fieldsProp, docLevelValidate) {
    var access, validate;
    validate = type["_".concat(fieldsProp, "Validate")] = validateStructure(type, fieldsProp);
    access = void 0;
    return function (result, fields, options) {
      var goodForAction, oldSave, optName, optValue, opts, save;
      opts = {
        result: result,
        mask: void 0,
        required: type[fieldsProp].$$tags.required,
        strict: true,
        beforeAction: false,
        beforeSave: false
      };

      if (options !== void 0) {
        if (!(_typeof(options) === 'object' && options !== null && !Array.isArray(options))) {
          invalidArg('options', options);
        }

        for (optName in options) {
          optValue = options[optName];

          switch (optName) {
            case 'access':
              access = optValue;
              break;

            case 'mask':
              opts.mask = optValue;
              break;

            case 'strict':
              opts.strict = optValue;
              break;

            case 'beforeSave':
              opts.beforeSave = optValue;
              break;

            case 'beforeAction':
              opts.beforeAction = optValue;
              break;

            default:
              unknownOption(optName);
          }
        }
      }

      save = true;
      goodForAction = opts.beforeAction;

      if (!access) {
        access = (fieldsProp === 'fields' ? type : type[fieldsProp]).$$access(fields, null);
      }

      if (!opts.mask) {
        opts.mask = opts.beforeAction ? access.view.or(access.update) : access.update;
      }

      opts.required = access.required;

      try {
        result.error = function () {
          // перехватываем сообщения об ошибках
          var msg;
          msg = Result.prototype.error.apply(result, arguments);

          if (msg.type === 'error') {
            goodForAction = false;

            if (~['validate.invalidValue', 'validate.unknownField', 'validate.unexpectedField'].indexOf(msg.code)) {
              save = false;
            }
          }

          return msg; // result.error = () ->
        };

        validate.call(opts, fields, void 0, fields, opts.beforeSave && opts.beforeAction ? void 0 : fields.$$touched);
        oldSave = save;

        if (save && opts.beforeAction && typeof docLevelValidate === 'function') {
          docLevelValidate.call(opts, result, fields);
        }
      } finally {
        result.error = Result.prototype.error;
      }

      return {
        save: oldSave,
        goodForAction: goodForAction
      };
    };
  }; // ----------------------------


  module.exports = $$validateBuilder;
}).call(void 0);