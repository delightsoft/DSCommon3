"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var Result, _addValidate, cvResult, emptyOnlyFields, moment, processCustomValidate, validate, validateStructureBuilder;

  Result = require('../result/index');
  processCustomValidate = require('./processCustomValidate');
  moment = require('moment');
  emptyOnlyFields = Object.freeze({});

  validateStructureBuilder = function validateStructureBuilder(type) {
    var fieldsProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fields';
    return function (value, fieldsLevel, doc, onlyFields) {
      var _this = this;

      var err, field, fieldName;

      if (!(_typeof(value) === 'object' && value !== null && !Array.isArray(value))) {
        return this.result.error('validate.invalidValue', {
          value: value
        });
      }

      err = void 0;
      fieldName = void 0;
      this.result.context(function (path) {
        return Result.prop(fieldName)(path);
      }, function () {
        var alwaysValidate, field, fieldValue, results;
        results = [];

        for (fieldName in value) {
          fieldValue = value[fieldName];

          if (!(fieldName[0] === '$' || fieldName[0] === '_')) {
            if (!type[fieldsProp].hasOwnProperty(fieldName)) {
              if (_this.strict) {
                results.push(err = _this.result.error('validate.unknownField', {
                  value: fieldValue
                }) || err);
              } else {
                results.push(void 0);
              }
            } else {
              field = type[fieldsProp][fieldName];
              alwaysValidate = field.type === 'structure' || field.type === 'subtable';

              if (!(!_this.mask || _this.mask.get(field.$$index))) {
                if (_this.strict) {
                  results.push(err = _this.result.error('validate.unexpectedField', {
                    value: fieldValue
                  }) || err);
                } else {
                  results.push(void 0);
                }
              } else if (!onlyFields || onlyFields[field.name] || alwaysValidate) {
                results.push(err = field._validate.call(_this, fieldValue, value, doc, onlyFields ? _typeof(fieldValue) === 'object' && fieldValue !== null && !Array.isArray(fieldValue) ? fieldValue.$$touched : emptyOnlyFields : void 0) || err);
              } else {
                results.push(void 0);
              }
            }
          }
        }

        return results;
      });

      if (this.beforeAction) {
        field = void 0;
        this.result.context(function (path) {
          return Result.prop(field.name)(path);
        }, function () {
          var j, len1, ref, ref1, results;
          ref = type[fieldsProp].$$list;
          results = [];

          for (j = 0, len1 = ref.length; j < len1; j++) {
            field = ref[j];

            if ((!_this.mask || _this.mask.get(field.$$index)) && ((ref1 = _this.required) != null ? ref1.get(field.$$index) : void 0) && !value.hasOwnProperty(field.name) && (!onlyFields || onlyFields[field.name])) {
              results.push(err = _this.result.error('validate.requiredField') || err);
            }
          }

          return results;
        });
      }

      return err; // (value, fieldsLevel, doc, onlyFields) ->
    };
  };

  _addValidate = function addValidate(fields, doc, validators) {
    fields.$$list.forEach(function (f) {
      f._validate = validate(f, fields, doc, validators);

      if (f.fields) {
        _addValidate(f.fields, doc, validators);
      }
    });
    return fields; // addValidate =
  };

  cvResult = new Result();

  validate = function validate(fieldDesc, fieldsLevelDesc, docDesc, validators) {
    var customValidator, f;

    f = function () {
      switch (fieldDesc.type) {
        case 'string':
          (function (len) {
            return f = function f(value) {
              var ref;

              if (typeof value !== 'string') {
                return this.result.error('validate.invalidValue', {
                  value: value
                });
              }

              if (!(value.length <= len)) {
                return this.result.error('validate.tooLong', {
                  value: value,
                  max: len
                });
              }

              if (this.beforeAction && value.length === 0 && ((ref = this.required) != null ? ref.get(fieldDesc.$$index) : void 0)) {
                return this.result.error('validate.requiredField');
              }
            };
          })(fieldDesc.length);

          if (fieldDesc.hasOwnProperty('min')) {
            (function (pf) {
              var min;
              min = fieldDesc.min;

              f = function f(value) {
                var r;

                if (r = pf.apply(this, arguments)) {
                  return r;
                }

                if (this.beforeAction && !(min <= value.length)) {
                  return this.result.error('validate.tooShort', {
                    value: value,
                    min: min
                  });
                }
              };
            })(f);
          }

          if (fieldDesc.hasOwnProperty('regexp')) {
            (function (pf) {
              var regexp;
              regexp = fieldDesc.regexp;

              f = function f(value) {
                var r;

                if (r = pf.apply(this, arguments)) {
                  return r;
                }

                if (!(value.length === 0 || regexp.test(value))) {
                  return this.result.error('validate.invalidValue', {
                    value: value,
                    regexp: regexp.toString()
                  });
                }
              };
            })(f);
          }

          return f;
        // when 'string'

        case 'text':
          f = function f(value) {
            var ref;

            if (typeof value !== 'string') {
              return this.result.error('validate.invalidValue', {
                value: value
              });
            }

            if (this.beforeAction && value.length === 0 && ((ref = this.required) != null ? ref.get(fieldDesc.$$index) : void 0)) {
              return this.result.error('validate.requiredField');
            }
          };

          if (fieldDesc.hasOwnProperty('min')) {
            (function (pf) {
              var min;
              min = fieldDesc.min;

              f = function f(value) {
                var r;

                if (r = pf.apply(this, arguments)) {
                  return r;
                }

                if (this.beforeAction && !(min <= value.length)) {
                  return this.result.error('validate.tooShort', {
                    value: value,
                    min: min
                  });
                }
              };
            })(f);
          }

          if (fieldDesc.hasOwnProperty('max')) {
            (function (pf) {
              var max;
              max = fieldDesc.max;

              f = function f(value) {
                var r;

                if (r = pf.apply(this, arguments)) {
                  return r;
                }

                if (!(value.length <= max)) {
                  return this.result.error('validate.tooLong', {
                    value: value,
                    max: max
                  });
                }
              };
            })(f);
          }

          if (fieldDesc.hasOwnProperty('regexp')) {
            (function (pf) {
              var regexp;
              regexp = fieldDesc.regexp;

              f = function f(value) {
                var r;

                if (r = pf.apply(this, arguments)) {
                  return r;
                }

                if (!(value.length === 0 || regexp.test(value))) {
                  return this.result.error('validate.invalidValue', {
                    value: value,
                    regexp: regexp.toString()
                  });
                }
              };
            })(f);
          }

          return f;
        // when 'text'

        case 'boolean':
          return function (value) {
            if (typeof value !== 'boolean') {
              return this.result.error('validate.invalidValue', {
                value: value
              });
            }
          };

        case 'integer':
          f = function f(value) {
            if (!(typeof value === 'number' && Number.isInteger(value))) {
              return this.result.error('validate.invalidValue', {
                value: value
              });
            }
          };

          if (fieldDesc.hasOwnProperty('min')) {
            (function (pf) {
              var min;
              min = fieldDesc.min;

              f = function f(value, fieldsLevel, doc, onlyFields) {
                var r;

                if (r = pf.apply(this, arguments)) {
                  return r;
                }

                if (this.beforeAction && !(min <= value)) {
                  return this.result.error('validate.tooSmall', {
                    value: value,
                    min: min
                  });
                }
              };
            })(f);
          }

          if (fieldDesc.hasOwnProperty('max')) {
            (function (pf) {
              var max;
              max = fieldDesc.max;

              f = function f(value, fieldsLevel, doc, onlyFields) {
                var r;

                if (r = pf.apply(this, arguments)) {
                  return r;
                }

                if (this.beforeAction && !(value <= max)) {
                  return this.result.error('validate.tooBig', {
                    value: value,
                    max: max
                  });
                }
              };
            })(f);
          }

          return f;
        // when 'integer'

        case 'double':
          f = function f(value) {
            if (typeof value !== 'number') {
              this.result.error('validate.invalidValue', {
                value: value
              });
            }
          };

          if (fieldDesc.hasOwnProperty('min')) {
            (function (pf) {
              var min;
              min = fieldDesc.min;

              f = function f(value) {
                var r;

                if (r = pf.apply(this, arguments)) {
                  return r;
                }

                if (this.beforeAction && !(min <= value)) {
                  return this.result.error('validate.tooSmall', {
                    value: value,
                    min: min
                  });
                }
              };
            })(f);
          }

          if (fieldDesc.hasOwnProperty('max')) {
            (function (pf) {
              var max;
              max = fieldDesc.max;

              f = function f(value) {
                var r;

                if (r = pf.apply(this, arguments)) {
                  return r;
                }

                if (this.beforeAction && !(value <= max)) {
                  return this.result.error('validate.tooBig', {
                    value: value,
                    max: max
                  });
                }
              };
            })(f);
          }

          return f;
        // when 'double'

        case 'decimal':
          return f = function f(value) {};
        //        @result.error 'validate.invalidValue', value: value unless typeof value == 'number' and Number.isInteger(value)
        //        return
        //      if fieldDesc.hasOwnProperty('min')
        //        do (pf = f) ->
        //          min = fieldDesc.min
        //          f = (value, fieldsLevel, doc, onlyFields) ->
        //            return r if r = pf.apply @, arguments
        //            return @result.error 'validate.tooSmall', value: value, min: min if @beforeAction and not (min <= value)
        //            return
        //          return
        //      if fieldDesc.hasOwnProperty('max')
        //        do (pf = f) ->
        //          max = fieldDesc.max
        //          f = (value, fieldsLevel, doc, onlyFields) ->
        //            return r if r = pf.apply @, arguments
        //            return @result.error 'validate.tooBig', value: value, max: max if @beforeAction and not (value <= max)
        //            return
        //          return
        //      f # when 'double'

        case 'date':
          return function (value) {
            var m;

            if (typeof value !== 'string') {
              return this.result.error('validate.invalidValue', {
                value: value
              });
            } else {
              m = moment(value, 'YYYY-MM-DD');

              if (!(m.isValid() && m._pf.unusedInput.length === 0)) {
                return this.result.error('validate.invalidValue', {
                  value: value
                });
              }
            }
          };

        case 'time':
          return function (value) {
            var m;

            if (typeof value !== 'string') {
              return this.result.error('validate.invalidValue', {
                value: value
              });
            } else {
              m = moment(value, ['HH:mmZ', 'HH:mm:ssZ', 'HH:mm:ss.SSSZ'], true);

              if (!(m.isValid() && m._pf.unusedInput.length === 0)) {
                return this.result.error('validate.invalidValue', {
                  value: value
                });
              }
            }
          };

        case 'timestamp':
          return function (value) {
            var m;

            if (typeof value !== 'string') {
              return this.result.error('validate.invalidValue', {
                value: value
              });
            } else {
              m = moment(value, ['YYYY-MM-DDTHH:mmZ', 'YYYY-MM-DDTHH:mm:ssZ', 'YYYY-MM-DDTHH:mm:ss.SSSZ']);

              if (!(m.isValid() && m._pf.unusedInput.length === 0)) {
                return this.result.error('validate.invalidValue', {
                  value: value
                });
              }
            }
          };
        // TODO: Add timetz, timestamptz

        case 'enum':
          return function (value) {
            if (!(typeof value === 'string' && fieldDesc["enum"].hasOwnProperty(value))) {
              return this.result.error('validate.invalidValue', {
                value: value
              });
            }
          };

        case 'structure':
          return validateStructureBuilder(fieldDesc);

        case 'subtable':
          return function () {
            var validateStructure;
            validateStructure = validateStructureBuilder(fieldDesc);
            return function (value, fieldsLevel, doc, onlyFields) {
              var _this2 = this;

              var err, i, ref;

              if (!Array.isArray(value)) {
                return this.result.error('validate.invalidValue', {
                  value: value
                });
              }

              if (((ref = this.required) != null ? ref.get(fieldDesc.$$index) : void 0) && value.length === 0) {
                return this.result.error('validate.invalidValue', {
                  value: value
                });
              }

              i = void 0;
              err = void 0;
              this.result.context(function (path) {
                return Result.index(i)(path);
              }, function () {
                var j, len1, results, row;
                results = [];

                for (i = j = 0, len1 = value.length; j < len1; i = ++j) {
                  row = value[i];
                  results.push(err = validateStructure.call(_this2, row, void 0, doc, onlyFields ? row.$$touched : void 0) || err);
                }

                return results;
              });
              return err; // (@result, value, fieldsLevel, doc, mask) ->
            };
          }();

        case 'nanoid':
          return function (value) {
            if (!(typeof value === 'string' && value.length === 21)) {
              return this.result.error('validate.invalidValue', {
                value: value
              });
            }
          };

        case 'json':
          return function (value) {};

        case 'refers':
          return function (refers) {
            return function (value) {
              if (typeof value === 'string') {
                return;
              } else if (_typeof(value) === 'object' && value !== null && typeof value.id === 'string') {
                if (!(!_typeof(value._type) === 'string' || refers.length === 0 || ~refers.indexOf(value._type))) {
                  this.result.error('validate.invalidDocType', {
                    value: value,
                    refers: refers
                  });
                }

                return;
              }

              return this.result.error('validate.invalidValue', {
                value: value
              });
            };
          }(fieldDesc.refers.map(function (v) {
            return v.name;
          }));

        default:
          throw new Error("Unexpected type: ".concat(JSON.stringify(fieldDesc)));
      }
    }();

    if (fieldDesc["null"]) {
      (function (pf) {
        return f = function f(value) {
          var ref;

          if (value !== null) {
            return pf.apply(this, arguments);
          } else if (this.beforeAction && ((ref = this.required) != null ? ref.get(fieldDesc.$$index) : void 0)) {
            return this.result.error('validate.requiredField', {
              value: value
            });
          }
        };
      })(f);
    } // если нет docDesc, значит это вызов из _processExtraProp, когда customValidator не используется


    customValidator = docDesc && processCustomValidate(cvResult, fieldDesc, fieldsLevelDesc, docDesc, validators);
    cvResult.throwIfError();

    if (customValidator) {
      (function (pf) {
        return f = function f(value, fieldsLevel, doc, onlyFields) {
          var r;

          if (r = pf.apply(this, arguments)) {
            return r;
          }

          if (this.beforeAction || customValidator.basic) {
            customValidator(this.result, value, fieldsLevel, doc, this.beforeAction);
          }

          return this.result.isError;
        };
      })(f);
    }

    return f; // index =
  }; // ----------------------------


  module.exports = validate;
  validate.structure = validateStructureBuilder;
  validate.addValidate = _addValidate;
}).call(void 0);