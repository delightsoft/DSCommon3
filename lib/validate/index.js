"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var Result, _addValidate, cvResult, emptyOnlyFields, moment, processCustomValidate, validate, validateStructureBuilder;

  Result = require('../result/index');
  processCustomValidate = require('./processCustomValidate');
  moment = require('moment');
  emptyOnlyFields = Object.freeze({});

  validateStructureBuilder = function validateStructureBuilder(type) {
    var fieldsProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fields';
    return function (result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeActiom) {
      var err, field, fieldName;

      if (!(_typeof(value) === 'object' && value !== null && !Array.isArray(value))) {
        return result.error('validate.invalidValue', {
          value: value
        });
      }

      err = void 0;
      fieldName = void 0;
      result.context(function (path) {
        return Result.prop(fieldName)(path);
      }, function () {
        var alwaysValidate, field, fieldValue, results;
        results = [];

        for (fieldName in value) {
          fieldValue = value[fieldName];

          if (!(fieldName[0] === '$' || fieldName[0] === '_')) {
            if (!type[fieldsProp].hasOwnProperty(fieldName)) {
              if (strict) {
                results.push(err = result.error('validate.unknownField', {
                  value: fieldValue
                }) || err);
              } else {
                results.push(void 0);
              }
            } else {
              field = type[fieldsProp][fieldName];
              alwaysValidate = field.type === 'structure' || field.type === 'subtable';

              if (!(!mask || mask.get(field.$$index))) {
                if (strict) {
                  results.push(err = result.error('validate.unexpectedField', {
                    value: fieldValue
                  }) || err);
                } else {
                  results.push(void 0);
                }
              } else if (!onlyFields || onlyFields[field.name] || alwaysValidate) {
                results.push(err = field._validate(result, fieldValue, value, doc, mask, requiredMask, onlyFields ? _typeof(fieldValue) === 'object' && fieldValue !== null && !Array.isArray(fieldValue) ? fieldValue.$$touched : emptyOnlyFields : void 0, strict, beforeActiom) || err);
              } else {
                results.push(void 0);
              }
            }
          }
        }

        return results;
      });

      if (beforeActiom) {
        field = void 0;
        result.context(function (path) {
          return Result.prop(field.name)(path);
        }, function () {
          var j, len1, ref, results;
          ref = type[fieldsProp].$$list;
          results = [];

          for (j = 0, len1 = ref.length; j < len1; j++) {
            field = ref[j];

            if ((!mask || mask.get(field.$$index)) && (field.required || (requiredMask != null ? requiredMask.get(field.$$index) : void 0)) && !value.hasOwnProperty(field.name) && (!onlyFields || onlyFields[field.name])) {
              results.push(err = result.error('validate.requiredField') || err);
            }
          }

          return results;
        });
      }

      return err; // (result, value, fieldsLevel, doc, mask, onlyFields) ->
    };
  };

  _addValidate = function addValidate(fields, doc, validators) {
    fields.$$list.forEach(function (f) {
      f._validate = validate(f, fields, doc, validators);

      if (f.fields) {
        _addValidate(f.fields, doc, validators);
      }
    });
    return fields; // addValidate =
  };

  cvResult = new Result();

  validate = function validate(fieldDesc, fieldsLevelDesc, docDesc, validators) {
    var customValidator, f;

    f = function () {
      switch (fieldDesc.type) {
        case 'string':
          (function (len) {
            return f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
              if (typeof value !== 'string') {
                return result.error('validate.invalidValue', {
                  value: value
                });
              }

              if (!(value.length <= len)) {
                return result.error('validate.tooLong', {
                  value: value,
                  max: len
                });
              }

              if (beforeAction && value.length === 0 && (fieldDesc.required || (requiredMask != null ? requiredMask.get(fieldDesc.$$index) : void 0))) {
                return result.error('validate.requiredField');
              }
            };
          })(fieldDesc.length);

          if (fieldDesc.hasOwnProperty('min')) {
            (function (pf) {
              var min;
              min = fieldDesc.min;

              f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
                var r;

                if (r = pf.apply(void 0, arguments)) {
                  return r;
                }

                if (beforeAction && !(min <= value.length)) {
                  return result.error('validate.tooShort', {
                    value: value,
                    min: min
                  });
                }
              };
            })(f);
          }

          if (fieldDesc.hasOwnProperty('regexp')) {
            (function (pf) {
              var regexp;
              regexp = fieldDesc.regexp;

              f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
                var r;

                if (r = pf.apply(void 0, arguments)) {
                  return r;
                }

                if (!(value.length === 0 || regexp.test(value))) {
                  return result.error('validate.invalidValue', {
                    value: value,
                    regexp: regexp.toString()
                  });
                }
              };
            })(f);
          }

          return f;
        // when 'string'

        case 'text':
          f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
            if (typeof value !== 'string') {
              return result.error('validate.invalidValue', {
                value: value
              });
            }

            if (beforeAction && value.length === 0 && (fieldDesc.required || (requiredMask != null ? requiredMask.get(fieldDesc.$$index) : void 0))) {
              return result.error('validate.requiredField');
            }
          };

          if (fieldDesc.hasOwnProperty('min')) {
            (function (pf) {
              var min;
              min = fieldDesc.min;

              f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
                var r;

                if (r = pf.apply(void 0, arguments)) {
                  return r;
                }

                if (beforeAction && !(min <= value.length)) {
                  return result.error('validate.tooShort', {
                    value: value,
                    min: min
                  });
                }
              };
            })(f);
          }

          if (fieldDesc.hasOwnProperty('max')) {
            (function (pf) {
              var max;
              max = fieldDesc.max;

              f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
                var r;

                if (r = pf.apply(void 0, arguments)) {
                  return r;
                }

                if (beforeAction && !(value.length <= max)) {
                  return result.error('validate.tooLong', {
                    value: value,
                    max: max
                  });
                }
              };
            })(f);
          }

          if (fieldDesc.hasOwnProperty('regexp')) {
            (function (pf) {
              var regexp;
              regexp = fieldDesc.regexp;

              f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
                var r;

                if (r = pf.apply(void 0, arguments)) {
                  return r;
                }

                if (!(value.length === 0 || regexp.test(value))) {
                  return result.error('validate.invalidValue', {
                    value: value,
                    regexp: regexp.toString()
                  });
                }
              };
            })(f);
          }

          return f;
        // when 'text'

        case 'boolean':
          return function (result, value) {
            if (typeof value !== 'boolean') {
              return result.error('validate.invalidValue', {
                value: value
              });
            }
          };

        case 'integer':
          f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
            if (!(typeof value === 'number' && Number.isInteger(value))) {
              return result.error('validate.invalidValue', {
                value: value
              });
            }
          };

          if (fieldDesc.hasOwnProperty('min')) {
            (function (pf) {
              var min;
              min = fieldDesc.min;

              f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
                var r;

                if (r = pf.apply(void 0, arguments)) {
                  return r;
                }

                if (beforeAction && !(min <= value)) {
                  return result.error('validate.tooSmall', {
                    value: value,
                    min: min
                  });
                }
              };
            })(f);
          }

          if (fieldDesc.hasOwnProperty('max')) {
            (function (pf) {
              var max;
              max = fieldDesc.max;

              f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
                var r;

                if (r = pf.apply(void 0, arguments)) {
                  return r;
                }

                if (beforeAction && !(value <= max)) {
                  return result.error('validate.tooBig', {
                    value: value,
                    max: max
                  });
                }
              };
            })(f);
          }

          return f;
        // when 'integer'

        case 'double':
          f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
            if (typeof value !== 'number') {
              result.error('validate.invalidValue', {
                value: value
              });
            }
          };

          if (fieldDesc.hasOwnProperty('min')) {
            (function (pf) {
              var min;
              min = fieldDesc.min;

              f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
                var r;

                if (r = pf.apply(void 0, arguments)) {
                  return r;
                }

                if (beforeAction && !(min <= value)) {
                  return result.error('validate.tooSmall', {
                    value: value,
                    min: min
                  });
                }
              };
            })(f);
          }

          if (fieldDesc.hasOwnProperty('max')) {
            (function (pf) {
              var max;
              max = fieldDesc.max;

              f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
                var r;

                if (r = pf.apply(void 0, arguments)) {
                  return r;
                }

                if (beforeAction && !(value <= max)) {
                  return result.error('validate.tooBig', {
                    value: value,
                    max: max
                  });
                }
              };
            })(f);
          }

          return f;
        // when 'double'

        case 'date':
          return function (result, value) {
            if (!(typeof value === 'string' && moment(value, 'YYYY-MM-DD').isValid())) {
              return result.error('validate.invalidValue', {
                value: value
              });
            }
          };

        case 'time':
          return function (result, value) {
            if (!(typeof value === 'string' && moment(value, ['HH:mm', 'HH:mm:ss', 'HH:mm:ss.SSS'], true).isValid())) {
              return result.error('validate.invalidValue', {
                value: value
              });
            }
          };

        case 'timestamp':
          return function (result, value) {
            if (!(typeof value === 'string' && moment(value, ['YYYY-MM-DDTHH:mm', 'YYYY-MM-DDTHH:mm:ss', 'YYYY-MM-DDTHH:mm:ss.SSS']).isValid())) {
              return result.error('validate.invalidValue', {
                value: value
              });
            }
          };
        // TODO: Add timetz, timestamptz

        case 'enum':
          return function (result, value) {
            if (!(typeof value === 'string' && fieldDesc["enum"].hasOwnProperty(value))) {
              return result.error('validate.invalidValue', {
                value: value
              });
            }
          };

        case 'structure':
          return validateStructureBuilder(fieldDesc);

        case 'subtable':
          return function () {
            var validateStructure;
            validateStructure = validateStructureBuilder(fieldDesc);
            return function (result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
              var err, i;

              if (!Array.isArray(value)) {
                return result.error('validate.invalidValue', {
                  value: value
                });
              }

              if ((fieldDesc.required || (requiredMask != null ? requiredMask.get(fieldDesc.$$index) : void 0)) && value.length === 0) {
                return result.error('validate.invalidValue', {
                  value: value
                });
              }

              result.isError = false;
              i = void 0;
              err = void 0;
              result.context(function (path) {
                return Result.index(i)(path);
              }, function () {
                var j, len1, results, row;
                results = [];

                for (i = j = 0, len1 = value.length; j < len1; i = ++j) {
                  row = value[i];
                  results.push(err = validateStructure(result, row, void 0, doc, mask, requiredMask, onlyFields ? row.$$touched : void 0, strict, beforeAction) || err);
                }

                return results;
              });
              return err; // (result, value, fieldsLevel, doc, mask) ->
            };
          }();

        case 'nanoid':
          return function (result, value) {
            if (!(typeof value === 'string' && value.length === 21)) {
              return result.error('validate.invalidValue', {
                value: value
              });
            }
          };

        case 'json':
          return function (result, value) {
            if (typeof value !== 'string') {
              return result.error('validate.invalidValue', {
                value: value
              });
            }

            try {
              JSON.parse(value);
            } catch (error) {
              return result.error('validate.invalidValue', {
                value: value
              });
            }
          };

        case 'refers':
          break;

        default:
          // nothing TODO:
          throw new Error("Unexpected type: ".concat(JSON.stringify(fieldDesc)));
      }
    }();

    if (fieldDesc["null"]) {
      (function (pf) {
        return f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
          if (value !== null) {
            return pf.apply(void 0, arguments);
          } else if (beforeAction && (fieldDesc.required || (requiredMask != null ? requiredMask.get(fieldDesc.$$index) : void 0))) {
            return result.error('validate.requiredField', {
              value: value
            });
          }
        };
      })(f);
    } // если нет docDesc, значит это вызов из _processExtraProp, когда customValidator не используется


    customValidator = docDesc && processCustomValidate(cvResult, fieldDesc, fieldsLevelDesc, docDesc, validators);
    cvResult.throwIfError();

    if (customValidator) {
      (function (pf) {
        return f = function f(result, value, fieldsLevel, doc, mask, requiredMask, onlyFields, strict, beforeAction) {
          var r;

          if (r = pf.apply(void 0, arguments)) {
            return r;
          }

          result.isError = false;

          if (beforeAction || customValidator.basic) {
            customValidator(result, value, fieldsLevel, doc, beforeAction);
          }

          return result.isError;
        };
      })(f);
    }

    return f; // index =
  }; // ----------------------------


  module.exports = validate;
  validate.structure = validateStructureBuilder;
  validate.addValidate = _addValidate;
}).call(void 0);