"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var Result, builtInTypes, checkEnumName, checkUDTypeName, compile, copyExtra, extraProps, invalidArg, invalidArgValue, isResult, processExraProps, reservedTypes, setRequiredProp, sortedMap, takeBoolean, takeEnum, takePositiveInt, takeString, takeStringOrArrayOfStrings, tooManyArgs, typeProps;

  var _require = require('../utils');

  checkUDTypeName = _require.checkUDTypeName;
  var _require$err = _require.err;
  tooManyArgs = _require$err.tooManyArgs;
  invalidArg = _require$err.invalidArg;
  invalidArgValue = _require$err.invalidArgValue;
  isResult = _require$err.isResult;
  Result = require('../result');

  var _require2 = require('../utils');

  checkEnumName = _require2.checkEnumName;
  sortedMap = require('../sortedMap');
  processExraProps = require('./_processExraProps');
  copyExtra = require('../config/_copyExtra');
  typeProps = ['length', 'enum', 'precision', 'scale', 'fields', 'refers', 'valueClass', 'null', 'required'];
  extraProps = ['min', 'max', 'regexp', 'init'];
  builtInTypes = ['string', 'text', 'boolean', 'integer', 'double', 'decimal', 'time', 'date', 'dateonly', 'timestamp', 'json', 'blob', 'uuid', 'enum', 'structure', 'subtable', 'refers', 'dsvalue'];
  reservedTypes = ['long', 'float'];

  compile = function compile(result, fieldDesc, res, opts) {
    var enumProp, fieldsProp, i, j, len, len1, lengthProp, nullProp, options, optionsEnd, optionsIndex, optionsLen, optsContext, precisionProp, prop, refersProp, requiredProp, scaleProp, sourceType, type, valueClass;

    if (!isResult(result)) {
      invalidArg('result', result);
    }

    if (!(_typeof(fieldDesc) === 'object' && fieldDesc !== null)) {
      invalidArg('fieldDesc', fieldDesc);
    }

    if (!(res === void 0 || _typeof(res) === 'object' && res !== null && !Array.isArray(res))) {
      invalidArg('res', fieldDesc);
    }

    if (!(opts === void 0 || _typeof(opts) === 'object' && opts !== null && !Array.isArray(opts))) {
      invalidArg('opts', opts);
    }

    if (!(arguments.length <= 4)) {
      tooManyArgs();
    }

    if (!(opts != null ? opts.hasOwnProperty('context') : void 0)) {
      // list of prop that should not be reported in validation
      optsContext = null; // any
    } else {
      if (!((optsContext = opts.context) === 'field' || optsContext === 'udtype')) {
        invalidArgValue('opts.context', opts.context);
      }
    }

    if (!!fieldDesc.hasOwnProperty('$$tags')) {
      throw new Error("fieldDesc was already process by tags/compile()");
    } // Определяем тип.  То что в скобках выделяем в options.


    if (fieldDesc.hasOwnProperty('type')) {
      if ((optionsIndex = (type = sourceType = fieldDesc.type.trim()).indexOf('(')) !== -1) {
        if (!((optionsEnd = options = type.indexOf(')')) > optionsIndex)) {
          // missing ) or it's before (
          result.error('dsc.invalidTypeValue', {
            value: type
          });
          return;
        }

        if (optionsEnd !== type.length - 1) {
          // something after )
          result.error('dsc.invalidTypeValue', {
            value: type
          });
          return;
        }

        if ((optionsLen = optionsEnd - optionsIndex - 1) === 0) {
          result.error('dsc.invalidTypeValue', {
            value: type
          });
          return;
        }

        options = type.substr(optionsIndex + 1, optionsLen);
        type = type.substr(0, optionsIndex).trim();
      }

      if (!checkUDTypeName(type)) {
        result.error('dsc.invalidTypeValue', {
          value: type
        });
        return;
      } // Если тип не указан, пробуем его определить по косвенному признаку

    } else if (fieldDesc.hasOwnProperty('enum')) {
      type = 'enum';
    } else if (fieldDesc.hasOwnProperty('fields')) {
      type = 'structure';
    } else if (fieldDesc.hasOwnProperty('refers')) {
      type = 'refers';
    } else {
      result.error('dsc.missingProp', {
        value: 'type'
      });
      return;
    } // Заменяем короткие имена типов на полные


    switch (type) {
      case 'str':
        type = 'string';
        break;

      case 'bool':
        type = 'boolean';
        break;

      case 'int':
        type = 'integer';
        break;

      case 'struct':
        type = 'structure';
        break;

      case 'ref':
        type = 'refers';
        break;

      case 'value':
        type = 'dsvalue';
    } // Проверяем, что тип входит в список типов


    if (!(builtInTypes.indexOf(type) >= 0)) {
      if (reservedTypes.indexOf(type) >= 0) {
        // reserved type name
        result.error('dsc.reservedType', {
          value: sourceType
        });
      } else if (options) {
        // udType cannot have an option
        result.error('dsc.unknownType', {
          value: sourceType // user defined type

        });
      } else {
        prop = void 0;
        result.context(function (path) {
          return Result.prop(prop)(path);
        }, function () {
          var i, len, results; // udType can have null in a field definition

          results = [];

          for (i = 0, len = typeProps.length; i < len; i++) {
            prop = typeProps[i];

            if (fieldDesc.hasOwnProperty(prop) && prop !== 'null') {
              results.push(result.error('dsc.notApplicableForTheTypeProp', {
                nameValue: prop,
                typeValue: type
              }));
            }
          }

          return results;
        });
        res.udType = type;

        if (typeof nullProp === 'boolean') {
          res["null"] = nullProp;
        }

        if (!result.isError) {
          return res;
        }
      }

      return;
    }

    if ((optsContext === null || optsContext === 'field') && type === 'dsvalue') {
      result.error('dsc.notAllowedInFieldDef', {
        value: type
      });
      return;
    } // Проверяем, наличие всех свойств относящихся к типу.  Если свойство не должно быть у данного типа, добавляем ошибку


    prop = lengthProp = enumProp = precisionProp = scaleProp = fieldsProp = nullProp = requiredProp = refersProp = valueClass = void 0;

    if (fieldDesc.hasOwnProperty('udType')) {
      result.error('dsc.reservedAttr', {
        value: 'udType'
      });
    }

    result.context(function (path) {
      return Result.prop(prop)(path);
    }, function () {
      var i, len, ok, results;
      results = [];

      for (i = 0, len = typeProps.length; i < len; i++) {
        prop = typeProps[i];

        if (!fieldDesc.hasOwnProperty(prop)) {
          continue;
        }

        ok = false;

        switch (prop) {
          case 'length':
            if (ok = type === 'string') {
              lengthProp = takePositiveInt(result, fieldDesc.length);
            }

            break;

          case 'enum':
            if (ok = type === 'enum') {
              enumProp = takeEnum(result, fieldDesc["enum"]);
            }

            break;

          case 'precision':
            if (ok = type === 'decimal') {
              precisionProp = takePositiveInt(result, fieldDesc.precision);
            }

            break;

          case 'scale':
            if (ok = type === 'decimal') {
              scaleProp = takePositiveInt(result, fieldDesc.scale);
            }

            break;

          case 'fields':
            ok = type === 'structure' || type === 'subtable'; // this prop is already taken during flatMap

            break;

          case 'null':
            if (optsContext === null || optsContext === 'field') {
              if (ok = !(type === 'timestamp' || type === 'structure' || type === 'subtable')) {
                nullProp = takeBoolean(result, fieldDesc["null"]);
              }
            } else {
              ok = true;
              result.error('dsc.notApplicableInUdtype');
            }

            break;

          case 'required':
            ok = true;

            if (optsContext === null || optsContext === 'field') {
              requiredProp = takeBoolean(result, fieldDesc.required);
            } else {
              result.error('dsc.notApplicableInUdtype');
            }

            break;

          case 'refers':
            if (ok = type === 'refers') {
              refersProp = takeStringOrArrayOfStrings(result, fieldDesc.refers);
            }

        }

        if (!(ok || extraProps.indexOf(prop) >= 0)) {
          results.push(result.error('dsc.notApplicableForTheTypeProp', {
            nameValue: prop,
            typeValue: type
          }));
        } else {
          results.push(void 0);
        }
      }

      return results;
    }); // работаем с length для string

    if (result.isError) {
      delete fieldDesc.type;

      for (i = 0, len = typeProps.length; i < len; i++) {
        prop = typeProps[i];
        delete fieldDesc[prop];
      }

      return;
    }

    if (options) {
      result.context(function (path) {
        return Result.prop("(".concat(options, ")"))(path);
      }, function () {
        var lengthPropFromOptions, refersPropFromOptions;

        switch (type) {
          case 'string':
            lengthPropFromOptions = takePositiveInt(result, parseFloat(options));

            if (lengthProp) {
              return result.error('dsc.ambiguousProp', {
                name: 'length',
                value1: lengthPropFromOptions || options,
                value2: lengthProp
              });
            } else {
              return lengthProp = lengthPropFromOptions;
            }

            break;

          case 'refers':
            if ((refersPropFromOptions = options.trim()).length === 0) {
              return result.error('dsc.invalidValue', {
                value: options
              });
            } else if (refersProp) {
              return result.error('dsc.ambiguousProp', {
                name: 'refers',
                value1: refersPropFromOptions || options,
                value2: refersProp
              });
            } else {
              return refersProp = refersPropFromOptions;
            }

            break;

          default:
            return result.error('dsc.unknownType', {
              value: sourceType
            });
        }
      });
    } // собираем результирующую структуру


    if (result.isError) {
      delete fieldDesc.type;

      for (j = 0, len1 = typeProps.length; j < len1; j++) {
        prop = typeProps[j];
        delete fieldDesc[prop];
      }

      return;
    }

    res.type = type;

    if (typeof requiredProp === 'boolean' && requiredProp) {
      res.required = true;
    }

    if (typeof nullProp === 'boolean' && nullProp) {
      res["null"] = true;
    }

    switch (type) {
      case 'string':
        setRequiredProp(result, res, 'length', lengthProp);
        break;

      case 'enum':
        setRequiredProp(result, res, 'enum', enumProp);
        break;

      case 'decimal':
        setRequiredProp(result, res, 'precision', precisionProp);

        if (typeof scaleProp === 'number') {
          res.scale = scaleProp;
        }

        break;

      case 'structure':
        if (!fieldDesc.hasOwnProperty('fields')) {
          result.error('dsc.missingProp', {
            value: 'fields'
          });
        }

        if (!res.hasOwnProperty('fields')) {
          result.error(Result.prop('fields'), 'dsc.invalidValue', {
            value: fieldDesc.fields
          });
        }

        break;

      case 'subtable':
        if (!fieldDesc.hasOwnProperty('fields')) {
          result.error('dsc.missingProp', {
            value: 'fields'
          });
        }

        if (!res.hasOwnProperty('fields')) {
          result.error(Result.prop('fields'), 'dsc.invalidValue', {
            value: fieldDesc.fields
          });
        }

        break;

      case 'refers':
        setRequiredProp(result, res, 'refers', refersProp);
    }

    if (!result.isError) {
      processExraProps(result, fieldDesc, res);
    }

    return res; // compile =
  }; // пропускаем целое позитивное число


  takePositiveInt = function takePositiveInt(result, value) {
    if (!(typeof value === 'number' && !isNaN(value) && Number.isInteger(value) && value > 0)) {
      result.error('dsc.invalidValue', {
        value: value
      });
      return;
    }

    return value; // parseLength =
  };

  takeBoolean = function takeBoolean(result, value) {
    if (typeof value !== 'boolean') {
      result.error('dsc.invalidValue', {
        value: value
      });
      return;
    }

    return value; // takeBoolean =
  };

  takeString = function takeString(result, value) {
    if (typeof value === 'string') {
      return value;
    }

    result.error('dsc.invalidValue', {
      value: value // takeString =

    });
  };

  takeStringOrArrayOfStrings = function takeStringOrArrayOfStrings(result, value) {
    var ok;

    if (typeof value === 'string') {
      return value;
    } else if (Array.isArray(value)) {
      ok = true;

      if (!value.some(function (s) {
        return typeof s !== 'string';
      })) {
        return value;
      }
    }

    result.error('dsc.invalidValue', {
      value: value // takeStringOrArrayOfStrings =

    });
  }; // enum может быть или массив строк или строка, со значениями разделеннымм запятыми.
  // массив должен быть не пустой. значения в нем уникальными. пустых строк быть не должно.


  takeEnum = function takeEnum(result, value) {
    var res;
    res = sortedMap(result, value, {
      string: true,
      "boolean": true
    });

    if (!result.isError) {
      copyExtra(result, res);
    }

    if (!result.isError) {
      sortedMap.finish(result, res);
    }

    return res;
  }; // присваиваем значение в res, если оно есть.  а если значения нет - добавляем ошибку


  setRequiredProp = function setRequiredProp(result, res, propName, value) {
    if (typeof value === 'undefined') {
      result.error('dsc.missingProp', {
        value: propName
      });
      return;
    }

    res[propName] = value; // setRequiredProp =
  }; // ----------------------------


  module.exports = compile;
  compile._builtInTypes = builtInTypes;
  compile._reservedTypes = reservedTypes;
  compile._typeProps = typeProps;
  compile._extraProps = extraProps;
}).call(void 0);