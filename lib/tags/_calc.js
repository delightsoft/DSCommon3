"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var BitArray, Result, _listTokenizer, _tokenizer, calc, i, iNextToken, invalidArg, isResult, tooManyArgs;

  var _require = require('../utils');

  var _require$err = _require.err;
  tooManyArgs = _require$err.tooManyArgs;
  invalidArg = _require$err.invalidArg;
  isResult = _require$err.isResult;
  Result = require('../result');
  BitArray = require('../bitArray');

  _tokenizer = function _tokenizer(result, expression) {
    var m, nextToken, p, s;
    p = -1;
    s = 0; // - начало строки,
    // 1 - пробел после имени элемента, тега или закрывающей скобки
    // 10 - имя элемента,
    // 20 - начало имени тега,
    // 21 - имя тега,
    // 22 - начало имени тега после namespace,
    // 23 - имя тега после namespace,
    // 30 - запятая, плюс или минус
    // 31 - после восклицательного знака
    // 100 - end

    m = null;

    nextToken = function nextToken() {
      var _char, wrong;

      while (true) {
        if (p + 1 === expression.length) {
          switch (s) {
            case 10:
            case 21:
            case 23:
              s = 1;
              return expression.substr(m, p - m + 1);
            // push back

            case 20:
            case 30:
            case 31:
              result.error('dsc.invalidExpression', {
                value: expression,
                position: p + 1
              });
              s = 100;
              return;
          }

          s = 100;
          return null;
        }

        _char = expression.charAt(++p);
        wrong = false;

        switch (s) {
          case 100:
            return null;

          case 0:
            if (/\s/i.test(_char)) {
              void 0;
            } else if (/[a-z0-9]/i.test(_char)) {
              s = 10;
              m = p;
            } else if (_char === '!') {
              s = 31;
              return '!';
            } else if (_char === '#') {
              s = 20;
              m = p;
            } else if (_char === '(') {
              s = 0;
              return '(';
            } else {
              wrong = true;
            }

            break;

          case 1:
            if (/\s/i.test(_char)) {
              void 0;
            } else if (_char === ',') {
              s = 30;
              return '+';
            } else if (_char === '+' || _char === '-' || _char === '&') {
              s = 30;
              return _char;
            } else if (_char === ')') {
              s = 1;
              m = p;
              return ')';
            } else {
              wrong = true;
            }

            break;

          case 10:
            if (/[a-z0-9\.]/i.test(_char)) {
              void 0;
            } else {
              p--;
              s = 1;
              return expression.substr(m, p - m + 1); // push back
            }

            break;

          case 20:
            if (/[a-z0-9]/.test(_char)) {
              s = 21;
            } else {
              wrong = true;
            }

            break;

          case 21:
            if (/[a-z0-9]/i.test(_char)) {
              void 0;
            } else if (_char === '.') {
              s = 22;
            } else {
              p--;
              s = 1;
              return expression.substr(m, p - m + 1); // push back
            }

            break;

          case 22:
            if (/[a-z0-9]/.test(_char)) {
              s = 23;
            } else {
              wrong = true;
            }

            break;

          case 23:
            if (/[a-z0-9]/i.test(_char)) {
              void 0;
            } else {
              p--;
              s = 1;
              return expression.substr(m, p - m + 1); // push back
            }

            break;

          case 30:
            if (/\s/i.test(_char)) {
              void 0;
            } else if (/[a-z0-9]/i.test(_char)) {
              s = 10;
              m = p;
            } else if (_char === '#') {
              s = 20;
              m = p;
            } else if (_char === '(') {
              s = 0;
              return '(';
            } else if (_char === '!') {
              s = 31;
              return '!';
            } else {
              wrong = true;
            }

            break;

          case 31:
            if (/\s/i.test(_char)) {
              void 0;
            } else if (/[a-z0-9]/i.test(_char)) {
              s = 10;
              m = p;
            } else if (_char === '#') {
              s = 20;
              m = p;
            } else if (_char === '(') {
              s = 0;
              return '(';
            } else {
              wrong = true;
            }

            break;

          default:
            throw new Error("Unexpected s: ".concat(s));
        }

        if (wrong) {
          result.error('dsc.invalidExpression', {
            value: expression,
            position: p
          });
          s = 100; // return ->

          return;
        }
      }
    };

    Object.defineProperty(nextToken, 'expr', {
      get: function get() {
        return expression;
      }
    });
    Object.defineProperty(nextToken, 'position', {
      get: function get() {
        if (s === 1) {
          return m;
        } else {
          return p;
        }
      }
    });
    return nextToken; // _tokenizer =
  };

  i = 0;
  iNextToken = void 0;

  _listTokenizer = function _listTokenizer(result, list) {
    var nextToken;
    nextToken = list.length === 0 ? function () {} : (iNextToken = _tokenizer(result, list[0]), function () {
      var token;

      if (iNextToken) {
        if (token = iNextToken()) {
          return token;
        } else if (++i < list.length) {
          if (result.isError) {
            return;
          }

          iNextToken = _tokenizer(result, list[i]);
          return '+';
        }
      }
    });
    Object.defineProperty(nextToken, 'expr', {
      get: function get() {
        return list[i];
      }
    });
    Object.defineProperty(nextToken, 'position', {
      get: function get() {
        return iNextToken != null ? iNextToken.position : void 0;
      }
    });
    return nextToken; // _tokenizer =
  };

  calc = function calc(result, collection, expression, options) {
    var _calcExpr2, expr, fieldMask, isFlat, level, levels, map, nextToken, optName, optValue, res, strict, tag, token;

    if (!isResult(result)) {
      invalidArg('result', result);
    }

    if (!(_typeof(collection) === 'object' && collection !== null && collection.hasOwnProperty('$$list'))) {
      invalidArg('collection', collection);
    }

    if (!(typeof expression === 'string' || Array.isArray(expression) && expression.every(function (v) {
      return typeof v === 'string';
    }))) {
      invalidArg('expression', expression);
    }

    if (!(arguments.length <= 4)) {
      tooManyArgs();
    }

    strict = true;

    if (options !== void 0) {
      if (!(_typeof(options) === 'object' && options !== null && !Array.isArray(options))) {
        invalidArg('options', options);
      }

      for (optName in options) {
        optValue = options[optName];

        switch (optName) {
          case 'strict':
            if (!(optValue === void 0 || typeof optValue === 'boolean')) {
              invalidOption('strict', optValue);
            }

            if (optValue !== void 0) {
              strict = optValue;
            }

        }
      }
    }

    nextToken = Array.isArray(expression) ? _listTokenizer(result, expression) : _tokenizer(result, expression);
    expr = [];
    levels = [];
    map = (isFlat = collection.hasOwnProperty('$$flat')) ? collection.$$flat : collection;

    while (token = nextToken()) {
      switch (token) {
        case '+':
        case '-':
        case '&':
        case '!':
          expr.push(token);
          break;

        case '(':
          expr.push(level = []);
          levels.push(expr);
          expr = level;
          break;

        case ')':
          if (!(levels.length > 0)) {
            result.error('dsc.unmatchParenthesis', {
              position: nextToken.position,
              value: nextToken.expr
            });
          } else {
            expr = levels.pop();
          }

          break;

        default:
          if (token.startsWith('#')) {
            // tag
            if (collection.$$tags.hasOwnProperty(tag = token.substr(1))) {
              expr.push(collection.$$tags[tag]);
            } else if (strict) {
              result.error('dsc.unknownTag', {
                expr: nextToken.expr,
                position: nextToken.position,
                value: tag
              });
            } else {
              expr.push(collection.$$tags.none); // field
            }
          } else {
            if (!map.hasOwnProperty(token)) {
              if (strict) {
                result.error('dsc.unknownItem', {
                  expr: nextToken.expr,
                  position: nextToken.position,
                  value: token
                });
              } else {
                expr.push(collection.$$tags.none);
              }
            } else {
              //          else if map[token].hasOwnProperty('$$mask')
              //            expr.push map[token].$$mask
              fieldMask = new BitArray(collection);
              fieldMask.set(map[token].$$index);
              expr.push(fieldMask);
            }
          }

      }
    }

    if (result.isError) {
      return;
    }

    if (levels.length > 0) {
      result.error('dsc.unmatchParenthesis', {
        position: expression.length,
        value: expression
      });
      return;
    }

    _calcExpr2 = function _calcExpr(expr) {
      var j, k, len, p, v;

      for (i = j = 0, len = expr.length; j < len; i = ++j) {
        v = expr[i];

        if (Array.isArray(v)) {
          expr[i] = _calcExpr2(v);
        }
      }

      for (i = k = expr.length - 1; k >= 0; i = k += -1) {
        v = expr[i];

        if (!(v === '!')) {
          continue;
        }

        expr[i + 1] = expr[i + 1].invert();
        expr.splice(i, 1);
      }

      p = 1;

      while (p < expr.length) {
        if ((v = expr[p]) === '+') {
          expr[p - 1] = expr[p - 1].or(expr[p + 1]);
          expr.splice(p, 2);
        } else if (v === '-') {
          expr[p - 1] = expr[p - 1].subtract(expr[p + 1]);
          expr.splice(p, 2);
        } else {
          p += 2;
        }
      }

      p = expr.length - 2;

      while (p > 0) {
        if (expr[p] === '&') {
          expr[p - 1] = expr[p - 1].and(expr[p + 1]);
        }

        p -= 2;
      }

      return expr[0];
    };

    res = _calcExpr2(expr);

    if (res) {
      // calc =
      res.list; // res.clearVertical() if isFlat

      return res;
    } else {
      return collection.$$tags.none;
    }
  }; // ----------------------------


  module.exports = calc;
  module.exports._tokenizer = _tokenizer; // for spec purposes
}).call(void 0);