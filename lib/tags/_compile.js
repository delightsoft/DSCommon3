"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  var BitArray, Result, checkTagName, checkTagsNamespace, compile, invalidArg, isResult, tooManyArgs;

  var _require = require('../utils');

  checkTagName = _require.checkTagName;
  checkTagsNamespace = _require.checkTagsNamespace;
  var _require$err = _require.err;
  tooManyArgs = _require$err.tooManyArgs;
  invalidArg = _require$err.invalidArg;
  isResult = _require$err.isResult;
  Result = require('../result');
  BitArray = require('../bitArray');

  compile = function compile(result, collection) {
    var _addTag, isFlat, item, k, list, propName, tags, v;

    if (!isResult(result)) {
      invalidArg('result', result);
    }

    if (!(_typeof(collection) === 'object' && collection !== null && collection.hasOwnProperty('$$list'))) {
      invalidArg('collection', collection);
    }

    if (!(arguments.length <= 2)) {
      tooManyArgs();
    }

    tags = {
      all: new BitArray(collection).invert()
    };

    _addTag = function _addTag(result, dupCheck, tag, item, namespace) {
      if ((tag = tag.trim()).length > 0) {
        if (namespace) {
          if (tag.indexOf('.') !== -1) {
            return result.error('dsc.ambiguousNamespaces', {
              value1: "tags.".concat(namespace),
              value2: tag
            });
          } else {
            tag = "".concat(namespace, ".").concat(tag);
          }
        }

        if (dupCheck.hasOwnProperty(tag)) {
          result.warn('dsc.duplicatedTag', {
            value: tag
          });
        } else {
          dupCheck[tag] = true;

          if (!checkTagName(tag)) {
            result.error('dsc.invalidName', {
              value: tag
            });
          } else if (tag === 'all') {
            result.error('dsc.reservedName', {
              value: 'all'
            });
          } else if (tag === 'system') {
            result.error('dsc.reservedName', {
              value: 'system'
            });
          } else {
            (tags.hasOwnProperty(tag) ? tags[tag] : tags[tag] = new BitArray(collection)).set(item.$$index);
          }
        }
      }
    };

    list = (isFlat = collection.hasOwnProperty('$$flat')) ? collection.$$flat.$$list : collection.$$list;
    item = void 0;
    propName = void 0;
    result.context(function (path) {
      return Result.prop(propName, Result.prop(item.name))(path);
    }, function () {
      var dotIndex, dupCheck, i, j, len, namespace, results, srcTags, tag, tagsProps;
      results = [];

      for (j = 0, len = list.length; j < len; j++) {
        item = list[j];

        if (!item.hasOwnProperty('$$src')) {
          continue;
        }

        tagsProps = item.$$src.hasOwnProperty('tags') ? ['tags'] : [];

        for (propName in item.$$src) {
          if (propName.startsWith('tags.') || propName.startsWith('tags_')) {
            if (!checkTagsNamespace(propName)) {
              result.error('dsc.invalidProp', {
                value: propName
              });
            } else {
              tagsProps.push(propName);
            }
          }
        }

        dupCheck = {};
        namespace = void 0;
        results.push(function () {
          var l, len1, results1;
          results1 = [];

          for (l = 0, len1 = tagsProps.length; l < len1; l++) {
            propName = tagsProps[l];

            if ((dotIndex = propName.indexOf('.')) !== -1 || (dotIndex = propName.indexOf('_')) !== -1) {
              namespace = propName.substr(dotIndex + 1);
            }

            srcTags = item.$$src[propName];

            if (namespace) {
              // так как имена свойвст содержат namespace, то проще их удалить во время обработки, чем формировать список для sortedMap.finish
              delete item.$$src[propName];
            }

            if (typeof srcTags === 'string') {
              results1.push(function () {
                var len2, m, ref, results2;
                ref = srcTags.split(',');
                results2 = [];

                for (m = 0, len2 = ref.length; m < len2; m++) {
                  tag = ref[m];
                  results2.push(_addTag(result, dupCheck, tag, item, namespace));
                }

                return results2;
              }());
            } else if (Array.isArray(srcTags)) {
              results1.push(function () {
                var len2, m, results2;
                results2 = [];

                for (i = m = 0, len2 = srcTags.length; m < len2; i = ++m) {
                  tag = srcTags[i];

                  if (typeof tag === 'string') {
                    results2.push(_addTag(result, dupCheck, tag, item, namespace));
                  } else {
                    results2.push(result.error('dsc.invalidTagValue', {
                      value: tag,
                      index: i
                    }));
                  }
                }

                return results2;
              }());
            } else {
              results1.push(result.error('dsc.invalidValue', {
                value: srcTags
              }));
            }
          }

          return results1;
        }());
      }

      return results;
    });

    if (isFlat) {
      for (k in tags) {
        v = tags[k];
        v.fixVertical();
      }
    }

    collection.$$tags = tags;
    return collection; // compiler =
  }; // ----------------------------


  module.exports = compile;
}).call(void 0);